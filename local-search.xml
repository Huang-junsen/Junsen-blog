<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript内功修炼：内存管理与分代垃圾回收机制详解</title>
    <link href="/2024/08/17/JavaScript%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2024/08/17/JavaScript%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript内功修炼：内存管理与分代垃圾回收机制详解"><a href="#JavaScript内功修炼：内存管理与分代垃圾回收机制详解" class="headerlink" title="JavaScript内功修炼：内存管理与分代垃圾回收机制详解"></a>JavaScript内功修炼：内存管理与分代垃圾回收机制详解</h1><h2 id="JavaScript引擎的由来"><a href="#JavaScript引擎的由来" class="headerlink" title="JavaScript引擎的由来"></a>JavaScript引擎的由来</h2><blockquote><p>JavaScript引擎的发展历史可以追溯到1995年，当时Netscape公司在其Netscape Navigator浏览器中引入了一种名为LiveScript的脚本语言。随后，这种语言被更名为JavaScript。随着互联网的快速发展，JavaScript迅速成为Web开发的核心语言，用于为网页添加交互性和动态内容。</p><p>JavaScript引擎的由来和发展是与Web的发展密不可分的。自1995年JavaScript诞生以来，JavaScript引擎经历了从简单的解释器到复杂的即时编译引擎的演变过程。这些引擎的不断进化，推动了Web技术的发展，使现代Web应用具备了丰富的交互性和高效的性能。今天，V8、JavaScriptCore、SpiderMonkey和Chakra等引擎，继续在不断优化和创新，为开发者提供强大的工具，以应对未来Web开发的挑战。</p></blockquote><h3 id="1-JavaScript的诞生与初期发展"><a href="#1-JavaScript的诞生与初期发展" class="headerlink" title="1. JavaScript的诞生与初期发展"></a><strong>1. JavaScript的诞生与初期发展</strong></h3><ul><li><strong>JavaScript的起源：</strong><ul><li>1995年，Netscape公司雇佣了Brendan Eich，他在短短10天内开发了JavaScript的第一个版本。最初，JavaScript的设计目的是为网页开发者提供一种简单的脚本语言，使他们能够轻松地为网页添加动态行为。</li><li>1996年，Microsoft公司在其Internet Explorer浏览器中推出了JScript，这是一个与JavaScript兼容的版本。为了避免专利纠纷，Microsoft将其命名为JScript。</li></ul></li><li><strong>早期的JavaScript引擎：</strong><ul><li><strong>SpiderMonkey（1995）：</strong> Brendan Eich为Netscape Navigator编写的第一个JavaScript引擎，被称为SpiderMonkey。它是JavaScript的初代引擎，负责将JavaScript代码解析并执行在Web浏览器中。</li><li><strong>JScript引擎（1996）：</strong> Microsoft开发的JScript引擎，首次集成在Internet Explorer 3.0中，使得JavaScript在浏览器领域得到更广泛的应用。</li></ul></li></ul><h3 id="2-JavaScript引擎的进化"><a href="#2-JavaScript引擎的进化" class="headerlink" title="2. JavaScript引擎的进化"></a><strong>2. JavaScript引擎的进化</strong></h3><blockquote><p>随着Web应用的复杂性不断增加，JavaScript引擎也在不断进化，以提高代码执行效率并支持更多的语言特性。</p></blockquote><ul><li><strong>Rhino（1997）：</strong><ul><li>由Mozilla基金会开发，Rhino是第一个JavaScript引擎的Java实现版本。它主要用于服务器端应用程序中，特别是在Java应用中嵌入JavaScript脚本。</li></ul></li><li><strong>JavaScriptCore（2003）：</strong><ul><li>Apple在开发Safari浏览器时，引入了JavaScriptCore引擎，这是WebKit浏览器引擎的一部分。JavaScriptCore的引入标志着JavaScript引擎从单纯的解释执行向更高效的字节码执行模式过渡。</li></ul></li><li><strong>V8引擎（2008）：</strong><ul><li>由Google开发的V8引擎是JavaScript引擎发展中的一个重要里程碑。V8引擎使用即时编译（JIT）技术，将JavaScript代码直接编译为机器码，大幅提升了代码的执行速度。V8引擎最初用于Google Chrome浏览器，后来被广泛应用于Node.js中。</li></ul></li><li><strong>SquirrelFish&#x2F;Nitro（2008）：</strong><ul><li>Apple为Safari浏览器开发了SquirrelFish引擎，并在随后的版本中进一步优化为Nitro引擎。这些引擎采用字节码解释器，显著提升了JavaScript代码的执行效率。</li></ul></li><li><strong>Chakra（2010）：</strong><ul><li>Microsoft为Internet Explorer 9开发了Chakra引擎，使用了类似V8的JIT编译技术，优化了JavaScript的执行速度。后来，Chakra引擎也用于Microsoft Edge浏览器。</li></ul></li></ul><h3 id="3-JavaScript引擎的现代化"><a href="#3-JavaScript引擎的现代化" class="headerlink" title="3. JavaScript引擎的现代化"></a><strong>3. JavaScript引擎的现代化</strong></h3><blockquote><p>随着JavaScript在Web开发中的地位越来越重要，现代JavaScript引擎在性能、内存管理和安全性等方面进行了大量优化。</p></blockquote><ul><li><strong>多线程与并行处理：</strong><ul><li>现代JavaScript引擎如V8和SpiderMonkey，采用了多线程和并行处理技术，允许在后台进行垃圾回收和JIT编译，从而最大限度地减少对主线程的影响，提升页面响应速度。</li></ul></li><li><strong>WebAssembly的支持：</strong><ul><li>为了应对对性能要求更高的Web应用，JavaScript引擎开始支持WebAssembly（Wasm），一种低级别的二进制格式，允许开发者在浏览器中运行接近本机速度的代码。</li></ul></li><li><strong>持续的性能优化：</strong><ul><li>现代JavaScript引擎不断优化其JIT编译器和垃圾回收机制，以应对日益复杂的Web应用，并提供更高的执行性能和更低的内存占用。</li></ul></li></ul><h2 id="为什么需要引擎它与垃圾回收之间的关联-？"><a href="#为什么需要引擎它与垃圾回收之间的关联-？" class="headerlink" title="为什么需要引擎它与垃圾回收之间的关联 ？"></a>为什么需要引擎它与垃圾回收之间的关联 ？</h2><blockquote><p>在JavaScript代码执行的过程中，内存管理是一个非常重要的方面。JavaScript引擎不仅负责代码的执行，还必须管理程序的内存使用，确保不再使用的内存能够被及时回收，以防止内存泄漏和系统性能的下降。这个内存管理的关键机制就是<strong>垃圾回收（Garbage Collection）</strong>。</p></blockquote><h3 id="1-内存管理的需求："><a href="#1-内存管理的需求：" class="headerlink" title="1. 内存管理的需求："></a><strong>1. 内存管理的需求：</strong></h3><ul><li><strong>自动内存管理：</strong> 与C或C++等手动管理内存的语言不同，JavaScript的内存管理是自动化的。开发者无需手动分配或释放内存，JavaScript引擎会自动管理对象的内存分配和释放。这大大降低了编程复杂性，同时也避免了常见的内存管理错误，如内存泄漏或悬空指针。</li></ul><h3 id="2-垃圾回收的工作原理："><a href="#2-垃圾回收的工作原理：" class="headerlink" title="2. 垃圾回收的工作原理："></a><strong>2. 垃圾回收的工作原理：</strong></h3><ul><li><strong>跟踪与回收：</strong> JavaScript引擎中的垃圾回收器（如V8的Orinoco）会跟踪内存中的所有对象，并识别那些不再被使用的对象。在大多数情况下，垃圾回收器使用“标记-清除”（Mark-and-Sweep）或“标记-整理”（Mark-and-Compact）算法来执行这些任务。</li><li><strong>内存回收的自动化：</strong> 垃圾回收器定期扫描内存中的对象，并回收那些不再被引用的对象所占用的内存。这一过程通常在引擎的后台进行，以尽量减少对代码执行的影响。</li></ul><h3 id="3-引擎和垃圾回收的协同工作："><a href="#3-引擎和垃圾回收的协同工作：" class="headerlink" title="3. 引擎和垃圾回收的协同工作："></a><strong>3. 引擎和垃圾回收的协同工作：</strong></h3><ul><li><strong>性能平衡：</strong> JavaScript引擎不仅要快速执行代码，还要在不影响性能的情况下进行垃圾回收。垃圾回收是一个计算密集型的任务，但如果不及时回收内存，可能会导致内存不足或应用程序性能下降。因此，现代引擎（如V8）通过增量垃圾回收、并行垃圾回收等技术，尽量减少垃圾回收对代码执行的中断。</li><li><strong>优化与去优化：</strong> 当JavaScript引擎优化代码时，它假设一定的内存模型和引用模式。如果这些假设在运行时被打破，引擎可能需要去优化代码，同时重新考虑内存管理策略。这就要求垃圾回收器和引擎紧密协作，动态调整内存管理和代码执行策略。</li></ul><h2 id="Nodejs整体架构"><a href="#Nodejs整体架构" class="headerlink" title="Nodejs整体架构"></a>Nodejs整体架构</h2><p><img src="https://tuchuang.junsen.online/i/2024/08/17/10e311p-2.png" alt="image-20240817220034250"></p><h3 id="1-Node-js标准库（Node-standard-lib）"><a href="#1-Node-js标准库（Node-standard-lib）" class="headerlink" title="1. Node.js标准库（Node standard lib）"></a><strong>1. Node.js标准库（Node standard lib）</strong></h3><blockquote><p>Node.js的标准库提供了丰富的API，用于处理文件系统、网络请求、流、缓冲区等常见任务。开发者可以直接使用这些标准库来构建应用程序，而无需手动处理底层细节。它是构建Node.js应用的核心组件，简化了开发过程，提供了统一的接口来操作各种系统资源。</p></blockquote><h3 id="2-绑定层（Binding）"><a href="#2-绑定层（Binding）" class="headerlink" title="2. 绑定层（Binding）"></a><strong>2. 绑定层（Binding）</strong></h3><blockquote><p>绑定层是Node.js中一个关键部分，它负责把Node.js的JavaScript代码与底层的C&#x2F;C++代码连接起来。简单来说，绑定层就像是一个“翻译官”，它让JavaScript代码可以直接调用底层系统功能，比如文件读写、网络通信等，这些功能通常是用C&#x2F;C++编写的，因为这些语言在处理这些任务时非常高效。</p><p>通过绑定层，Node.js能够充分利用这些底层功能的高性能，并把它们包装成容易使用的JavaScript接口，供开发者调用。这种设计让Node.js既保持了JavaScript的简单易用性，又拥有了接近底层系统的强大性能。</p></blockquote><h3 id="3-V8引擎"><a href="#3-V8引擎" class="headerlink" title="3. V8引擎"></a><strong>3. V8引擎</strong></h3><blockquote><p>V8是Google开发的JavaScript引擎，它将JavaScript代码编译成机器码，并高效执行。Node.js通过使用V8引擎来快速运行JavaScript代码，确保应用具备高性能。</p></blockquote><h3 id="4-libuv"><a href="#4-libuv" class="headerlink" title="4. libuv"></a><strong>4. libuv</strong></h3><blockquote><p>libuv是一个跨平台的支持库，负责提供事件驱动的异步I&#x2F;O操作、线程池管理、文件系统访问以及TCP&#x2F;UDP网络通信等功能。它是Node.js异步I&#x2F;O模型的核心，负责管理事件循环和线程池，从而使Node.js能够在不阻塞主线程的情况下，高效地处理大量并发连接。</p></blockquote><h3 id="5-C-ares"><a href="#5-C-ares" class="headerlink" title="5. C-ares"></a><strong>5. C-ares</strong></h3><blockquote><p>C-ares是一个异步DNS解析库，专门用于处理DNS查询操作。Node.js利用C-ares来异步处理DNS请求，确保这些操作不会阻塞主线程。C-ares的作用在于让Node.js能够高效地处理DNS查询，对于构建高性能网络应用至关重要，因为它避免了网络操作中的阻塞问题。</p></blockquote><h3 id="6-OpenSSL"><a href="#6-OpenSSL" class="headerlink" title="6. OpenSSL"></a><strong>6. OpenSSL</strong></h3><blockquote><p>OpenSSL是一个用于安全通信的加密库，负责实现SSL&#x2F;TLS协议。Node.js使用OpenSSL来加密网络通信，确保数据传输的安全性。OpenSSL为Node.js提供了加密功能，支持HTTPS和其他安全通信协议，是保障Node.js应用安全性的核心组件。</p></blockquote><h2 id="V8-引擎的简单介绍"><a href="#V8-引擎的简单介绍" class="headerlink" title="V8 引擎的简单介绍"></a>V8 引擎的简单介绍</h2><p><img src="https://tuchuang.junsen.online/i/2024/08/17/10ysp1i-2.jpg" alt="1723905317795"></p><h3 id="1-Heap-Memory-Allocation"><a href="#1-Heap-Memory-Allocation" class="headerlink" title="1. Heap Memory Allocation"></a>1. <strong>Heap Memory Allocation</strong></h3><ul><li><strong>堆内存分配</strong>：V8引擎负责管理和分配内存空间，主要通过堆（Heap）来分配对象和数据的内存。JavaScript中的所有对象和引用类型数据都在堆内存中存储。</li></ul><h3 id="2-Call-Stack-Execution-Context"><a href="#2-Call-Stack-Execution-Context" class="headerlink" title="2. Call Stack Execution Context"></a>2. <strong>Call Stack Execution Context</strong></h3><ul><li><strong>调用栈执行上下文</strong>：这是V8处理函数调用和执行顺序的地方。每当一个函数被调用时，一个新的执行上下文被创建并压入调用栈，执行完成后会弹出调用栈。这个过程确保了JavaScript代码的顺序执行。</li></ul><h3 id="3-Orinoco-Garbage-Collector"><a href="#3-Orinoco-Garbage-Collector" class="headerlink" title="3. Orinoco Garbage Collector"></a>3. <strong>Orinoco Garbage Collector</strong></h3><ul><li><strong>Orinoco垃圾回收器</strong>：这是V8引擎中的垃圾回收系统，负责自动回收不再使用的内存。Orinoco使用了一系列优化策略，如增量标记和并行清理，以最小化垃圾回收对程序性能的影响。</li></ul><h3 id="4-TurboFan-Optimization-Compiler"><a href="#4-TurboFan-Optimization-Compiler" class="headerlink" title="4. TurboFan Optimization Compiler"></a>4. <strong>TurboFan Optimization Compiler</strong></h3><ul><li><strong>TurboFan优化编译器</strong>：这是V8中的JIT（即时）编译器，专门负责将热点代码编译为高效的机器码。TurboFan会根据运行时收集的数据进行优化，提高代码的执行效率。</li></ul><h3 id="5-Ignition-JS-Interpreter"><a href="#5-Ignition-JS-Interpreter" class="headerlink" title="5. Ignition JS Interpreter"></a>5. <strong>Ignition JS Interpreter</strong></h3><ul><li><strong>Ignition JavaScript解释器</strong>：Ignition是V8的解释器，负责将JavaScript代码解析为字节码并执行。它是V8中最先执行JavaScript代码的组件，负责快速启动代码的执行。</li></ul><h3 id="6-Liftoff-WebAssembly"><a href="#6-Liftoff-WebAssembly" class="headerlink" title="6. Liftoff WebAssembly"></a>6. <strong>Liftoff WebAssembly</strong></h3><ul><li><strong>Liftoff WebAssembly编译器</strong>：Liftoff是V8引擎中专门为WebAssembly设计的编译器，负责将WebAssembly字节码编译为机器码并执行。WebAssembly是一种与JavaScript并行的低级语言，主要用于性能要求较高的应用场景。</li></ul><h3 id="V8-的处理过程"><a href="#V8-的处理过程" class="headerlink" title="V8 的处理过程"></a>V8 的处理过程</h3><p><img src="https://tuchuang.junsen.online/i/2024/08/17/10k3doc-2.jpg" alt="1723903849717"></p><h4 id="1-代码解析（Parsing）"><a href="#1-代码解析（Parsing）" class="headerlink" title="1. 代码解析（Parsing）"></a><strong>1. 代码解析（Parsing）</strong></h4><p>始于从网络中获取 JavaScript 代码，代码进入<strong>解析器（Parser）</strong>，被解析为<strong>抽象语法树（AST）</strong>。AST是代码的结构化表示，提供了代码的语法和逻辑结构。</p><h4 id="2-字节码生成与执行（Bytecode-Generation-and-Execution）"><a href="#2-字节码生成与执行（Bytecode-Generation-and-Execution）" class="headerlink" title="2. 字节码生成与执行（Bytecode Generation and Execution）"></a><strong>2. 字节码生成与执行（Bytecode Generation and Execution）</strong></h4><p>AST生成后，V8引擎的Ignition解释器将其转换为字节码。字节码是中间形式，介于源代码和机器码之间，适合在虚拟机中执行。 一旦字节码生成，V8引擎开始执行这些字节码。执行过程中，V8会收集代码的运行数据，包括类型信息和执行路径，这些数据将用于后续的优化步骤。</p><h4 id="3-动态优化（Dynamic-Optimization）"><a href="#3-动态优化（Dynamic-Optimization）" class="headerlink" title="3. 动态优化（Dynamic Optimization）"></a><strong>3. 动态优化（Dynamic Optimization）</strong></h4><p>在字节码执行的过程中，V8引擎会识别出热点代码——那些被频繁执行的代码段。引擎的<strong>TurboFan优化编译器</strong>对热点代码进行优化，生成更高效的机器码，提升代码执行速度。如果运行时的某些假设被证明不成立，V8引擎会触发<strong>去优化（Deoptimization）</strong>过程，将执行流程退回到字节码执行阶段，确保代码正确运行。</p><h2 id="为何需要垃圾回收？"><a href="#为何需要垃圾回收？" class="headerlink" title="为何需要垃圾回收？"></a>为何需要垃圾回收？</h2><blockquote><p>在JavaScript代码执行的过程中，内存管理是一个非常重要的方面。JavaScript引擎不仅负责代码的执行，还必须管理程序的内存使用，确保不再使用的内存能够被及时回收，以防止内存泄漏和系统性能的下降。这个内存管理的关键机制就是<strong>垃圾回收（Garbage Collection）</strong>。</p></blockquote><h3 id="1-内存管理的需求：-1"><a href="#1-内存管理的需求：-1" class="headerlink" title="1. 内存管理的需求："></a><strong>1. 内存管理的需求：</strong></h3><ul><li><strong>自动内存管理：</strong> 与C或C++等手动管理内存的语言不同，JavaScript的内存管理是自动化的。开发者无需手动分配或释放内存，JavaScript引擎会自动管理对象的内存分配和释放。这大大降低了编程复杂性，同时也避免了常见的内存管理错误，如内存泄漏或悬空指针。</li></ul><h3 id="2-垃圾回收的工作原理：-1"><a href="#2-垃圾回收的工作原理：-1" class="headerlink" title="2. 垃圾回收的工作原理："></a><strong>2. 垃圾回收的工作原理：</strong></h3><ul><li><strong>跟踪与回收：</strong> JavaScript引擎中的垃圾回收器（如V8的Orinoco）会跟踪内存中的所有对象，并识别那些不再被使用的对象。在大多数情况下，垃圾回收器使用“标记-清除”（Mark-and-Sweep）或“标记-整理”（Mark-and-Compact）算法来执行这些任务。</li><li><strong>内存回收的自动化：</strong> 垃圾回收器定期扫描内存中的对象，并回收那些不再被引用的对象所占用的内存。这一过程通常在引擎的后台进行，以尽量减少对代码执行的影响。</li></ul><h3 id="3-引擎和垃圾回收的协同工作：-1"><a href="#3-引擎和垃圾回收的协同工作：-1" class="headerlink" title="3. 引擎和垃圾回收的协同工作："></a><strong>3. 引擎和垃圾回收的协同工作：</strong></h3><ul><li><strong>性能平衡：</strong> JavaScript引擎不仅要快速执行代码，还要在不影响性能的情况下进行垃圾回收。垃圾回收是一个计算密集型的任务，但如果不及时回收内存，可能会导致内存不足或应用程序性能下降。因此，现代引擎（如V8）通过增量垃圾回收、并行垃圾回收等技术，尽量减少垃圾回收对代码执行的中断。</li><li><strong>优化与去优化：</strong> 当JavaScript引擎优化代码时，它假设一定的内存模型和引用模式。如果这些假设在运行时被打破，引擎可能需要去优化代码，同时重新考虑内存管理策略。这就要求垃圾回收器和引擎紧密协作，动态调整内存管理和代码执行策略。</li></ul><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h3><blockquote><p>在垃圾回收的过程中，“可达性”是判断对象是否可以被回收的关键概念。可达性指的是对象是否能够通过某种路径（如直接引用或间接引用）从“根对象”访问到。根对象包括全局变量、当前函数的局部变量和参数等，这些对象是垃圾回收器判定为“可达”的起点。</p><p>只要一个对象能够通过引用链从根对象访问到，它就是“活”的，并且不会被回收。根对象的来源不仅限于栈上的变量，还包括全局变量、闭包中捕获的变量、浏览器中的DOM元素引用等。垃圾回收器会定期检查这些引用链，以识别那些没有被任何可达对象引用的“孤立”对象，并将其从内存中回收。这种机制有效防止内存泄漏，确保程序的高效运行。</p></blockquote><h4 id="全局变量的引用链"><a href="#全局变量的引用链" class="headerlink" title="全局变量的引用链"></a>全局变量的引用链</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> globalObj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Global Object&quot;</span> &#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>globalObj</code>是一个全局变量，它是根对象的一部分。由于它直接被代码引用，并且没有任何途径使它变得不可达，因此它不会被垃圾回收。</li></ul><h4 id="函数内部的局部变量"><a href="#函数内部的局部变量" class="headerlink" title="函数内部的局部变量"></a>函数内部的局部变量</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> localObj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Local Object&quot;</span> &#125;;<br>    <span class="hljs-keyword">return</span> localObj;<br>&#125;<br><br><span class="hljs-keyword">let</span> obj = <span class="hljs-title function_">createObject</span>();<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>localObj</code>是函数内部的局部变量，但因为它被返回并赋值给了全局变量<code>obj</code>，所以即使函数执行完毕，<code>localObj</code>依然是可达的，因为它可以通过<code>obj</code>引用链访问到。</li></ul><h4 id="通过对象引用保持可达性"><a href="#通过对象引用保持可达性" class="headerlink" title="通过对象引用保持可达性"></a>通过对象引用保持可达性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Object 1&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Object 2&quot;</span>, <span class="hljs-attr">ref</span>: obj1 &#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：<code>localObj</code>是函数内部的局部变量，但因为它被返回并赋值给了全局变量<code>obj</code>，所以即使函数执行完毕，<code>localObj</code>依然是可达的，因为它可以通过<code>obj</code>引用链访问到。</li></ul><h4 id="闭包中的变量引用"><a href="#闭包中的变量引用" class="headerlink" title="闭包中的变量引用"></a>闭包中的变量引用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> closureObj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Closure Object&quot;</span> &#125;;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(closureObj.<span class="hljs-property">name</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> innerFunction;<br>&#125;<br><br><span class="hljs-keyword">let</span> func = <span class="hljs-title function_">outerFunction</span>();<br><span class="hljs-title function_">func</span>();<br></code></pre></td></tr></table></figure><ul><li><strong>解释</strong>：在这个例子中，<code>closureObj</code>是<code>outerFunction</code>内部的局部变量，但由于<code>innerFunction</code>闭包引用了<code>closureObj</code>，即使<code>outerFunction</code>执行完毕，<code>closureObj</code>仍然保持可达性，并不会被垃圾回收。</li></ul><h4 id="DOM元素的引用"><a href="#DOM元素的引用" class="headerlink" title="DOM元素的引用"></a>DOM元素的引用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myElement&quot;</span>);<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">elementRef</span>: element &#125;;<br></code></pre></td></tr></table></figure><p><strong>解释</strong>：<code>element</code>是一个DOM元素，它被<code>obj</code>对象的<code>elementRef</code>属性引用。因此，只要<code>obj</code>是可达的，那么DOM元素<code>element</code>也不会被垃圾回收。</p><h4 id="可达示例"><a href="#可达示例" class="headerlink" title="可达示例"></a>可达示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">exampleFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Object 1&quot;</span> &#125;;  <span class="hljs-comment">// 局部变量 obj1 是可达的</span><br>    <span class="hljs-keyword">let</span> obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Object 2&quot;</span>, <span class="hljs-attr">ref</span>: obj1 &#125;;  <span class="hljs-comment">// obj2 引用 obj1，obj1 仍然是可达的</span><br>    <span class="hljs-keyword">let</span> obj3 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Object 3&quot;</span> &#125;;  <span class="hljs-comment">// obj3 是可达的</span><br>    obj1 = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// obj1 被设置为 null，原本引用 obj1 的对象仍然存在，因此原本的 obj1 仍然是可达的</span><br>    <br>    <span class="hljs-keyword">return</span> obj2;  <span class="hljs-comment">// 函数返回 obj2，obj2 和它所引用的对象都仍然是可达的</span><br>&#125;<br><br><span class="hljs-keyword">let</span> globalObj = <span class="hljs-title function_">exampleFunction</span>();  <span class="hljs-comment">// globalObj 引用了 obj2，因此 obj2 是可达的</span><br></code></pre></td></tr></table></figure><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h5><ol><li><strong>初始状态：</strong><ul><li>当<code>exampleFunction()</code>被调用时，函数内部的<code>obj1</code>、<code>obj2</code>和<code>obj3</code>都是局部变量，它们都可以通过栈帧访问，因此它们是可达的。</li></ul></li><li><strong>引用关系：</strong><ul><li><code>obj2</code>引用了<code>obj1</code>，这意味着即使<code>obj1</code>不再被局部变量直接引用，它仍然通过<code>obj2</code>是可达的。</li><li><code>obj3</code>虽然是局部变量，但它没有其他引用，仅仅在函数内部可达。</li></ul></li><li><strong>设置<code>obj1</code>为null：</strong><ul><li>当<code>obj1</code>被设置为<code>null</code>时，函数内部的局部变量不再直接引用最初的<code>obj1</code>对象。然而，因为<code>obj2</code>引用了<code>obj1</code>，所以原来的<code>obj1</code>对象仍然是可达的。</li><li>这意味着<code>obj1</code>的内容仍然存在于内存中，未被垃圾回收。</li></ul></li><li><strong>函数返回后：</strong><ul><li><code>exampleFunction()</code>返回了<code>obj2</code>，并且<code>globalObj</code>引用了<code>obj2</code>。由于<code>obj2</code>是全局变量，垃圾回收器认为<code>obj2</code>是根对象，<code>obj2</code>及其引用的<code>obj1</code>对象都被保留在内存中。</li><li><code>obj3</code>在函数结束时失去引用，成为不可达的对象，因此<code>obj3</code>及其内容可能会被垃圾回收器回收。</li></ul></li></ol><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h5><ul><li><strong>可达性</strong>：在这个示例中，通过函数返回值和变量之间的引用链，<code>obj1</code>和<code>obj2</code>都保持了可达性，而<code>obj3</code>失去了可达性，最终会被垃圾回收。</li><li><strong>垃圾回收</strong>：垃圾回收器会回收那些不可达的对象，以释放内存。在这个例子中，<code>obj3</code>就是一个被垃圾回收器标记为不可达并可能最终回收的对象。</li></ul><h3 id="GC算法是什么？"><a href="#GC算法是什么？" class="headerlink" title="GC算法是什么？"></a>GC算法是什么？</h3><ul><li><strong>GC（Garbage Collection）</strong>是内存管理中的一种机制，负责自动回收不再使用的内存。具体的回收工作由 <strong>垃圾回收器（Garbage Collector）</strong>来完成。</li><li><strong>垃圾回收器的工作</strong>主要包括两个方面：一是查找哪些内存空间可以被释放（即识别哪些对象是“垃圾”），二是释放这些空间，使其可供程序再次使用。</li><li><strong>GC算法</strong>则是垃圾回收器在执行这些工作时所遵循的规则和方法。不同的GC算法采用不同的策略来确定哪些对象应该被回收，以及如何有效地管理内存，以尽量减少对程序性能的影响。</li></ul><h3 id="垃圾回收中常见的GC算法"><a href="#垃圾回收中常见的GC算法" class="headerlink" title="垃圾回收中常见的GC算法"></a>垃圾回收中常见的GC算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><blockquote><p>引用计数算法是一种常见的内存管理方法，通过跟踪每个值被引用的次数来决定何时回收内存。当一个变量被赋予一个引用类型的值时，引用次数增加；当该值被赋给其他变量时，引用次数进一步增加；如果变量被赋予新值或不再引用该值，引用次数则减少。当引用次数降为零时，说明该值已不再被使用，垃圾回收器会释放其占用的内存空间。这种方法有效地管理了内存，但也可能导致一些复杂的内存泄漏问题，如循环引用。</p></blockquote><h5 id="引用计数算法的实现原理"><a href="#引用计数算法的实现原理" class="headerlink" title="引用计数算法的实现原理"></a><strong>引用计数算法的实现原理</strong></h5><p>引用计数算法是一种简单而直观的内存管理机制，其核心思想是通过跟踪每个对象的引用次数来决定该对象是否应该被回收。以下是引用计数算法的基本实现原理：</p><p><strong>1. 引用计数的初始化</strong></p><ul><li>当一个对象被创建时，引用计数器会初始化为 1，表示该对象被至少一个变量引用。</li></ul><p><strong>2. 引用计数的增加</strong></p><ul><li>每当有一个新的引用指向该对象时（例如，将对象赋值给另一个变量），该对象的引用计数就会增加 1。</li></ul><p><strong>3. 引用计数的减少</strong></p><ul><li>当一个引用不再指向该对象时（例如，将变量赋值为 <code>null</code> 或将对象引用赋值为另一个对象），该对象的引用计数就会减少 1。</li></ul><p><strong>4. 引用计数为 0 时的回收</strong></p><ul><li>当某个对象的引用计数降为 0 时，说明没有任何变量或对象再引用它，因此该对象无法再被访问，垃圾回收器就会释放该对象占用的内存。</li></ul><p><strong>5. 循环引用问题</strong></p><ul><li>如果两个或多个对象之间存在循环引用，即它们互相引用但不再被其他对象引用，则它们的引用计数永远不会降为 0。这会导致这些对象无法被回收，从而引发内存泄漏。这是引用计数算法的一个主要缺陷。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Object A&quot;</span> &#125;;  <span class="hljs-comment">// a 的引用计数为 1</span><br><br><span class="hljs-keyword">let</span> b = a;  <span class="hljs-comment">// a 的引用计数增加为 2</span><br><br>a = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// a 的引用计数减少为 1</span><br><br>b = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// a 的引用计数降为 0，此时该对象可以被垃圾回收</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Object 1&quot;</span> &#125;; <br>    <span class="hljs-keyword">let</span> obj2 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Object 2&quot;</span> &#125;;<br><br>    <span class="hljs-comment">// obj1 引用 obj2</span><br>    obj1.<span class="hljs-property">ref</span> = obj2;<br><br>    <span class="hljs-comment">// obj2 引用 obj1，形成循环引用</span><br>    obj2.<span class="hljs-property">ref</span> = obj1;<br><br>    <span class="hljs-keyword">return</span> &#123; obj1, obj2 &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> objects = <span class="hljs-title function_">createObject</span>();<br><br><span class="hljs-comment">// 在这里，objects 引用了 obj1 和 obj2，因此 obj1 和 obj2 的引用计数都至少为 1</span><br><br><span class="hljs-comment">// 手动解除引用</span><br>objects = <span class="hljs-literal">null</span>; <br><br><span class="hljs-comment">// 虽然 objects 设为 null，obj1 和 obj2 仍然互相引用，导致它们的引用计数永远不会变为 0</span><br><span class="hljs-comment">// 因此，它们不会被垃圾回收器回收，造成内存泄漏</span><br><br></code></pre></td></tr></table></figure><p><strong>优点</strong><br>引用计数算法相较于标记清除算法有几个显著的优势：</p><ul><li><strong>即时回收</strong>：引用计数算法在对象的引用次数降为 0 时立即回收内存。这意味着垃圾一旦生成，便能立即释放内存，从而避免了内存堆积。</li><li><strong>无停顿回收</strong>：标记清除算法需要定期暂停应用程序执行来进行垃圾回收，这会导致短暂的性能停顿。而引用计数算法则不需要全局的停顿来执行垃圾回收，它的内存管理是分散在各个操作中的，因此不会引入明显的性能中断。</li><li><strong>简单高效</strong>：引用计数算法在引用和解除引用时更新计数，不需要像标记清除算法那样遍历整个堆内存的所有对象，这在某些情况下可以更加高效。</li></ul><p><strong>缺点</strong><br>引用计数算法也有一些明显的缺陷：</p><ul><li><strong>额外的计数器开销</strong>：每个对象都需要维护一个引用计数器，这个计数器需要占用内存空间。尤其是在引用较多时，这些计数器可能会占用大量的内存。</li><li><strong>无法处理循环引用</strong>：引用计数算法的最大问题是无法检测和处理循环引用。两个或多个对象互相引用时，即使它们不再被程序其他部分引用，它们的引用计数也不会降为 0，导致内存泄漏。</li></ul><blockquote><p>总之，虽然引用计数算法有其即时回收和无停顿回收的优点，但它在处理复杂引用关系和内存管理开销方面的不足也不可忽视。循环引用问题尤其严重，常常需要与其他垃圾回收算法结合使用以确保内存能被正确回收。</p></blockquote><h4 id="标记清除算法（mark-sweep）"><a href="#标记清除算法（mark-sweep）" class="headerlink" title="标记清除算法（mark-sweep）"></a>标记清除算法（mark-sweep）</h4><blockquote><p>标记-清除（Mark-Sweep）算法是现代垃圾回收器中广泛使用的一种算法。它通过两个主要阶段来管理内存：标记阶段和清除阶段。</p></blockquote><p><strong>1. 标记阶段（Mark Phase）</strong></p><p>在标记阶段，垃圾回收器会遍历所有的根对象（通常是全局对象、栈中的局部变量和静态变量等），并递归地标记所有从根对象可达的对象为“活动”（reachable）。</p><ul><li><strong>根对象</strong>：根对象是程序运行中始终存在的对象，通常包括全局变量、栈帧中的变量以及一些静态变量。</li><li><strong>可达对象</strong>：如果一个对象可以从根对象通过直接或间接的引用访问到，那么它被认为是可达的，且在标记阶段会被标记为“活动”。</li></ul><p><strong>2. 清除阶段（Sweep Phase）</strong></p><p>在清除阶段，垃圾回收器会扫描堆内存中的所有对象，并回收那些没有在标记阶段被标记为“活动”的对象，即不可达的对象。</p><ul><li><strong>未标记的对象</strong>：这些对象在标记阶段没有被标记，意味着它们无法通过任何引用链从根对象访问到。垃圾回收器将它们视为“垃圾”，并回收它们占用的内存。</li></ul><h5 id="标记清除算法的实现原理"><a href="#标记清除算法的实现原理" class="headerlink" title="标记清除算法的实现原理"></a><strong>标记清除算法的实现原理</strong></h5><p><strong>初始化：</strong></p><ul><li>垃圾收集器在启动时会假设内存中的所有对象都是垃圾，并为它们加上一个标记，将其全部标记为0。这相当于初始化，准备后续的遍历和清理工作。</li></ul><p><strong>标记阶段：</strong></p><ul><li>垃圾收集器从各个根对象（如全局变量、栈中的局部变量等）开始遍历内存，识别出那些仍然可达的对象。对于每一个可达的对象，垃圾收集器会将其标记改为1，表示它是“活动的”，即不会被回收。</li></ul><p><strong>清除阶段：</strong></p><ul><li>在标记阶段结束后，垃圾收集器会扫描内存中所有的对象，并清理那些仍然标记为0的对象。这些对象被视为垃圾，因此它们所占用的内存将被销毁并回收。</li></ul><p><strong>内存释放：</strong></p><ul><li>清除阶段结束后，被回收的内存可以再次分配给新创建的对象。</li></ul><p><strong>优点</strong></p><ol><li><strong>解决循环引用问题：</strong><ul><li>标记清除算法通过遍历根对象来标记可达对象，不依赖于引用计数，因此可以有效解决引用计数算法无法处理的循环引用问题。即使对象之间存在循环引用，只要它们是不可达的，最终都会被回收。</li></ul></li><li><strong>无需维护引用计数：</strong><ul><li>不像引用计数算法需要在每次引用增加或减少时更新计数，标记清除算法只在垃圾回收时进行一次标记和清除操作，减少了在正常程序执行中的开销。</li></ul></li><li><strong>通用性强：</strong><ul><li>标记清除算法适用于各种编程语言和内存管理需求，能够处理复杂的对象图，并且在很多现代垃圾回收器中都有使用。</li></ul></li></ol><p><strong>缺点</strong></p><ol><li><strong>程序停顿（Stop-the-World）：</strong><ul><li>在标记和清除阶段，程序执行需要暂停，这种“Stop-the-World”操作可能导致应用的响应速度下降，特别是在堆内存非常大时，这种停顿可能会较为明显。</li></ul></li><li><strong>内存碎片化：</strong><ul><li>清除阶段会释放不可达对象的内存，这可能导致内存空间变得不连续，形成内存碎片化。碎片化的内存空间虽然被回收了，但由于其分散性，可能难以用于分配新的大对象。</li></ul></li><li><strong>效率问题：</strong><ul><li>标记清除算法在每次垃圾回收时需要遍历整个对象图并扫描整个堆内存，这对大规模应用程序的性能可能会造成一定的影响，尤其是在堆内存很大或者对象很多的情况下。</li></ul></li></ol><p><img src="https://tuchuang.junsen.online/i/2024/08/17/130mmeg-2.png" alt="image-20240817235921347"></p><p><strong>总结</strong></p><blockquote><p>标记清除算法通过初始标记、遍历根对象标记可达对象、清理不可达对象以及重置标记四个步骤，实现了有效的垃圾回收。它能够识别并清除不再使用的内存空间，并且能够处理循环引用问题。然而，标记清除算法在运行过程中会暂停程序的执行，并可能导致内存碎片化，这些都是需要在实际应用中考虑的问题。</p></blockquote><h4 id="标记整理算法（Mark-Compact）"><a href="#标记整理算法（Mark-Compact）" class="headerlink" title="标记整理算法（Mark-Compact）"></a>标记整理算法（Mark-Compact）</h4><blockquote><p>标记整理（Mark-Compact）算法是标记清除算法的一个改进版本，旨在解决标记清除算法中存在的内存碎片化问题。标记整理算法通过将存活对象整理到内存的一端，从而将碎片化内存整理成连续的空闲空间，方便后续的内存分配。</p></blockquote><h5 id="标记整理算法的工作原理"><a href="#标记整理算法的工作原理" class="headerlink" title="标记整理算法的工作原理"></a>标记整理算法的工作原理</h5><blockquote><p>标记整理算法的执行过程可以分为以下几个阶段：</p></blockquote><p>标记阶段（Mark Phase）：</p><ul><li>与标记清除算法类似，垃圾回收器从根对象开始，遍历对象图，标记所有可达的对象为“活动”对象。这些对象将不会被回收。</li></ul><p><img src="https://tuchuang.junsen.online/i/2024/08/18/3tp5i-2.png" alt="image-20240818000640408"></p><p>整理阶段（Compact Phase）：</p><ul><li>在标记阶段之后，垃圾回收器会将所有存活的对象（即标记为“活动”的对象）向内存的一端移动，使内存中的活动对象排列得更加紧凑，减少内存碎片。这一步骤还会更新引用地址以确保它们指向正确的位置。</li></ul><p><img src="https://tuchuang.junsen.online/i/2024/08/18/3woi2-2.png" alt="image-20240818000654836"></p><p>释放未使用的内存：</p><ul><li>在整理阶段完成后，所有非活动对象占用的内存被回收，形成一个连续的空闲区域，等待新的对象分配。这时内存中的布局显示出活动对象被集中到一端，未使用的内存空间则完全被释放。</li></ul><p><img src="https://tuchuang.junsen.online/i/2024/08/18/48a1v-2.png" alt="image-20240818000708341"></p><h3 id="GC算法总结"><a href="#GC算法总结" class="headerlink" title="GC算法总结"></a>GC算法总结</h3><ul><li><p>引用计数</p><ol><li>可以即时回收垃圾对象</li><li>减少程序卡顿时间</li><li>无法回收循环引用的对象</li><li>资源消耗较大</li></ol></li><li><p>标记清除</p><p>   1.标记清除分两个阶段进行，首先标记活动对象，然后清除未标记的对象。 </p><p>​    2.可以回收循环引用的对象空间，是引用计数算法的改进。 </p><p>​    3.容易产生碎片化操作，无法最大化利用空间。 </p><p>​    4.垃圾对象不会被立即回收，而是在最后清除，可能导致程序停止工作。</p></li><li><p>标记整理</p><p>​    1.标记整理通过整理地址空间来解决标记清除的空间碎片化问题。</p><p>​    2.同样无法立即回收垃圾对象，相对于引用计数和标记清除是缺点。</p></li></ul><h3 id="V8引擎的内存限制"><a href="#V8引擎的内存限制" class="headerlink" title="V8引擎的内存限制"></a>V8引擎的内存限制</h3><h4 id="1-内存限制的背景"><a href="#1-内存限制的背景" class="headerlink" title="1. 内存限制的背景"></a><strong>1. 内存限制的背景</strong></h4><p>V8 引擎在不同环境下的内存限制有所不同，主要包括以下几个方面：</p><ul><li>桌面环境（如 Chrome 浏览器、桌面版 Node.js）：<ul><li>在 64 位系统上，V8 引擎的堆内存限制通常在 <strong>1.5 GB</strong> 到 <strong>2 GB</strong> 之间。</li><li>在 32 位系统上，这一限制较低，通常为 <strong>512 MB</strong> 到 <strong>1 GB</strong>。</li></ul></li><li>移动设备：<ul><li>在移动设备上，由于内存资源更为有限，V8 引擎的内存限制通常在 <strong>256 MB</strong> 到 <strong>512 MB</strong> 之间。</li></ul></li></ul><h4 id="2-内存限制的原因"><a href="#2-内存限制的原因" class="headerlink" title="2. 内存限制的原因"></a><strong>2. 内存限制的原因</strong></h4><ul><li>设备限制：<ul><li>不同设备的硬件能力，特别是内存容量的差异，决定了 V8 必须对内存使用进行严格控制，以确保在各种设备上都能高效运行。</li></ul></li><li>性能优化：<ul><li>V8 引擎通过设置内存限制，可以优化垃圾回收和内存管理，避免因内存过度占用导致的性能问题。例如，在内存紧张的情况下，垃圾回收频率可能会增加，以确保程序不会因内存不足而崩溃。</li></ul></li><li>安全性考虑：<ul><li>限制内存使用量还能够防止恶意脚本或程序占用过多的内存资源，从而影响系统的稳定性。这在浏览器环境和服务器端环境中都尤为重要，以防止内存泄漏或恶意攻击。</li></ul></li></ul><h4 id="3-Node-js-中的内存限制"><a href="#3-Node-js-中的内存限制" class="headerlink" title="3. Node.js 中的内存限制"></a><strong>3. Node.js 中的内存限制</strong></h4><blockquote><p>在 V8 引擎中，所有的 JavaScript 对象都存储在堆内存中。V8 对堆内存的大小设置了默认限制。在旧版本的 Node.js 中，64 位系统上的堆内存限制通常为 <strong>1.5 GB</strong> 左右，而在 32 位系统上为 <strong>0.7 GB</strong> 左右。随着 Node.js 的版本更新和硬件的提升，最新版本（如 <code>v20.14.0</code>）的堆内存限制已提升至 <strong>4 GB</strong>。如果一个 Node.js 进程的堆内存使用量超过了这个限制，进程就会由于内存不足而退出。由于 Node.js 是基于 V8 引擎构建的，因此 V8 通过其内部机制来管理和分配这些堆内存。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// v20.14.0 内存统计示例</span><br><span class="hljs-title class_">HeapStatistics</span>: &#123;<br>  <span class="hljs-attr">total_heap_size</span>: <span class="hljs-number">5455872</span>,<br>  <span class="hljs-attr">total_heap_size_executable</span>: <span class="hljs-number">262144</span>,<br>  <span class="hljs-attr">total_physical_size</span>: <span class="hljs-number">5455872</span>,<br>  <span class="hljs-attr">total_available_size</span>: <span class="hljs-number">4341839008</span>,<br>  <span class="hljs-attr">used_heap_size</span>: <span class="hljs-number">4397648</span>,<br>  <span class="hljs-attr">heap_size_limit</span>: <span class="hljs-number">4345298944</span>,<br>  <span class="hljs-attr">malloced_memory</span>: <span class="hljs-number">147504</span>,<br>  <span class="hljs-attr">peak_malloced_memory</span>: <span class="hljs-number">1204272</span>,<br>  <span class="hljs-attr">does_zap_garbage</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">number_of_native_contexts</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">number_of_detached_contexts</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">total_global_handles_size</span>: <span class="hljs-number">8192</span>,<br>  <span class="hljs-attr">used_global_handles_size</span>: <span class="hljs-number">2880</span>,<br>  <span class="hljs-attr">external_memory</span>: <span class="hljs-number">2275528</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="V8-的垃圾回收策略"><a href="#V8-的垃圾回收策略" class="headerlink" title="V8 的垃圾回收策略"></a>V8 的垃圾回收策略</h3><blockquote><p>V8 引擎采用了<strong>分代式垃圾回收机制</strong>，根据对象的存活时间将内存分为不同的代，然后对每个代采用不同的垃圾回收算法。这种策略旨在提高垃圾回收的效率，同时最大限度地减少对程序性能的影响。</p></blockquote><h3 id="V8引擎内存空间划分"><a href="#V8引擎内存空间划分" class="headerlink" title="V8引擎内存空间划分"></a><strong>V8引擎内存空间划分</strong></h3><ol><li><strong>Old Space（老生代空间）：</strong><ul><li><strong>黄色区域</strong>：表示老生代空间（Old Space），用于存储生命周期较长或永久存在的对象。这部分内存空间通常占用较大，因为随着程序运行，很多对象会从新生代晋升到老生代。</li></ul></li><li><strong>New Space（新生代空间）：</strong><ul><li><strong>浅蓝色区域</strong>：表示新生代空间（New Space），这是存放生命周期较短的小对象的区域。新生代通常会被分为两个部分，一个是活动的新生代空间，另一个是非活动的新生代空间（Inactive New Space），用于 Scavenge 算法的复制过程。</li></ul></li><li><strong>Large Object Space（大对象空间）：</strong><ul><li><strong>红色区域</strong>：表示大对象空间（Large Object Space），用于存储非常大的对象，这些对象由于太大而无法在新生代空间中管理，直接存放在这个专用空间中。</li></ul></li><li><strong>Code Space（代码空间）：</strong><ul><li><strong>蓝色区域</strong>：表示代码空间（Code Space），存储 JIT 编译后的可执行代码。</li></ul></li><li><strong>Map Space（映射空间）：</strong><ul><li><strong>深蓝色区域</strong>：表示映射空间（Map Space），用于存储对象的映射结构，即对象的形状信息（如对象的属性和方法布局）。</li></ul></li></ol><p><img src="https://tuchuang.junsen.online/i/2024/08/18/1o6fg0-2.jpg" alt="1723914063435"></p><h3 id="V8新生代与老生代分布图"><a href="#V8新生代与老生代分布图" class="headerlink" title="V8新生代与老生代分布图"></a>V8新生代与老生代分布图</h3><blockquote><p>在 V8 引擎的内存结构中，新生代（Young Generation）主要用于存放生命周期较短的对象。新生代内存由两个称为 Semispace（半空间）的区域组成，内存最大值在 64 位系统和 32 位系统上分别为 32 MB 和 16 MB。为了高效地管理和回收这些短生命周期的对象，新生代的垃圾回收主要采用 <strong>Scavenge</strong> 算法。</p></blockquote><p><img src="https://tuchuang.junsen.online/i/2024/08/18/1ucy7k-2.png" alt="image-20240818011143840"></p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><h4 id="1-对象分配"><a href="#1-对象分配" class="headerlink" title="1. 对象分配"></a>1. <strong>对象分配</strong></h4><ul><li>新生代内存（Young Generation）被分成两个相同大小的区域：<code>From Space</code> 和 <code>To Space</code>。</li><li>新分配的对象会先被放置在<code>From Space</code>中。</li></ul><h4 id="2-垃圾回收触发"><a href="#2-垃圾回收触发" class="headerlink" title="2. 垃圾回收触发"></a>2. <strong>垃圾回收触发</strong></h4><ul><li>当<code>From Space</code>空间快满时，V8的垃圾回收机制会触发一轮<strong>Minor GC</strong>（小型垃圾回收），也称为<strong>Scavenge</strong>。</li></ul><h4 id="3-对象复制"><a href="#3-对象复制" class="headerlink" title="3. 对象复制"></a>3. <strong>对象复制</strong></h4><ul><li><p>在进行垃圾回收时，V8会扫描<code>From Space</code>中的存活对象，并将它们复制到<code>To Space</code>。</p></li><li><p>在复制过程中，会更新所有指向这些对象的引用，以确保它们指向新位置。</p></li><li><p>垃圾（即不再被引用的对象）不会被复制，因此自然会被回收。</p><p><img src="https://tuchuang.junsen.online/i/2024/08/18/23vd66-2.jpg" alt="1723915659111"></p></li></ul><h4 id="4-空间交换"><a href="#4-空间交换" class="headerlink" title="4. 空间交换"></a>4. <strong>空间交换</strong></h4><ul><li><p>当复制完成后，<code>From Space</code>和<code>To Space</code>的角色会交换：</p><ul><li><p><code>From Space</code>（原来的<code>To Space</code>）成为新的活跃空间，用来存放接下来分配的新对象。</p></li><li><p><code>To Space</code>（原来的<code>From Space</code>）则被清空，等待下一次垃圾回收的使用。</p><p><img src="https://tuchuang.junsen.online/i/2024/08/18/249beu-2.jpg" alt="1723915682776"></p></li></ul></li></ul><h4 id="5-对象晋升"><a href="#5-对象晋升" class="headerlink" title="5. 对象晋升"></a>5. <strong>对象晋升</strong></h4><ul><li>如果一个对象在多次垃圾回收中都存活下来，V8会将该对象从新生代（Young Generation）移动到老生代（Old Generation），这称为<strong>晋升</strong>（Promotion）。老生代用于存储生命周期较长的对象，垃圾回收频率较低。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul><li><code>From Space</code> 和 <code>To Space</code> 是新生代（Young Generation）中的两个区域，它们在每次垃圾回收后交换角色。</li><li>新生代内存的垃圾回收采用复制收集算法，存活的对象被复制到新的空间，不再使用的对象则被丢弃。</li><li>多次垃圾回收后仍存活的对象将被晋升到老生代，以减少新生代内存的压力。</li></ul><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><blockquote><p>不同于新生代，老生代中存储的内容是相对使用频繁并且短时间无需清理回收的内容。这部分我们可以使用<strong>标记整理</strong>进行处理。</p><p>从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象</p><p>清除阶段老生代垃圾回收器会直接将非活动对象进行清除。</p></blockquote><h4 id="全停顿（Stop-The-World）与-V8-引擎的优化策略"><a href="#全停顿（Stop-The-World）与-V8-引擎的优化策略" class="headerlink" title="全停顿（Stop-The-World）与 V8 引擎的优化策略"></a>全停顿（Stop-The-World）与 V8 引擎的优化策略</h4><blockquote><p>由于 JavaScript 运行在主线程之上，一旦执行垃圾回收（Garbage Collection，GC），必须将正在执行的 JavaScript 脚本暂停，待垃圾回收完毕后再恢复脚本执行。这种行为称为 <strong>全停顿（Stop-The-World，STW）</strong>其实如果用前端开发的术语来解释，就是<strong>阻塞</strong>。</p></blockquote><h5 id="全停顿的影响"><a href="#全停顿的影响" class="headerlink" title="全停顿的影响"></a><strong>全停顿的影响</strong></h5><blockquote><p>STW 会导致系统出现周期性的卡顿，这对实时性要求高或与时间相关的任务影响尤为显著。例如，当 JavaScript 脚本需要执行动画效果时，如果恰好遇到 GC 过程，动画可能会出现卡顿现象，导致用户体验极差。</p></blockquote><h5 id="V8-引擎的优化策略：Orinoco"><a href="#V8-引擎的优化策略：Orinoco" class="headerlink" title="V8 引擎的优化策略：Orinoco"></a><strong>V8 引擎的优化策略：Orinoco</strong></h5><blockquote><p>为了降低 STW 导致的卡顿和性能不佳，V8 引擎引入了名为 <strong>Orinoco</strong> 的垃圾回收器。Orinoco 是 V8 团队经过多年不断优化和精细化调校后的成果，具备了多种优化手段，从而极大地提升了 GC 过程的性能和用户体验。</p></blockquote><h5 id="关键优化手段"><a href="#关键优化手段" class="headerlink" title="关键优化手段"></a><strong>关键优化手段</strong></h5><ol><li><strong>增量标记（Incremental Marking）</strong>：<ul><li>Orinoco 在垃圾回收过程中引入了增量标记技术，将标记阶段分解为多个小步骤，在 JavaScript 脚本执行的间隙进行。这种方式有效减少了 STW 导致的长时间卡顿现象。</li></ul></li><li><strong>并发标记（Concurrent Marking）</strong>：<ul><li>并发标记允许标记阶段和 JavaScript 脚本执行并行进行，这进一步降低了 STW 的影响，减少了用户感知到的卡顿时间。</li></ul></li><li><strong>并行清理（Parallel Sweeping）</strong>：<ul><li>在清理阶段，Orinoco 垃圾回收器可以利用多核处理器进行并行清理操作，从而加快垃圾回收过程，缩短 STW 时间。</li></ul></li><li><strong>延迟回收（Lazy Sweeping）</strong>：<ul><li>延迟回收技术允许垃圾回收器将部分非关键的清理工作延后进行，在不影响应用程序性能的情况下进一步减少卡顿。</li></ul></li></ol><h4 id="并行回收"><a href="#并行回收" class="headerlink" title="并行回收"></a>并行回收</h4><h5 id="什么是并行回收？"><a href="#什么是并行回收？" class="headerlink" title="什么是并行回收？"></a><strong>什么是并行回收？</strong></h5><blockquote><p>在传统的垃圾回收过程中，JavaScript 代码执行的主线程需要暂停一段时间，等垃圾回收完成后才能继续执行。这段时间我们称为 <strong>全停顿</strong>（Stop-the-World，STW）。如果这个暂停时间太长，比如几秒钟，用户可能会感觉到应用程序卡顿，尤其是在需要持续响应的场景下，如动画播放或游戏中。</p><p>为了改善这种情况，V8 引擎引入了 <strong>并行回收</strong> 技术。简单来说，就是把垃圾回收的工作分成几部分，让多个处理器核心同时进行这些工作，而不是让主线程一个个地完成所有任务。</p></blockquote><h5 id="并行回收如何工作？"><a href="#并行回收如何工作？" class="headerlink" title="并行回收如何工作？"></a>并行回收如何工作？</h5><blockquote><p><strong>任务分解</strong>：</p><ul><li>当垃圾回收器开始工作时，它不会一次性暂停所有的 JavaScript 代码执行并处理所有垃圾回收工作，而是把这个任务分解成几个较小的步骤。</li></ul><p><strong>多个处理器核心同时工作</strong>：</p><ul><li>这些较小的步骤会被分配给多个处理器核心，让它们并行处理。这样，垃圾回收的工作速度就能大大加快。</li></ul><p><strong>主线程的暂停时间减少</strong>：</p><ul><li>由于这些垃圾回收工作同时进行，主线程需要暂停的时间就被压缩到最小。比如，原本可能需要暂停 3 秒的垃圾回收工作，现在可以分成 3 个部分，每部分只暂停 1 秒。</li></ul></blockquote><h5 id="举个简单的例子"><a href="#举个简单的例子" class="headerlink" title="举个简单的例子"></a><strong>举个简单的例子</strong></h5><blockquote><p>想象一下，你和你的朋友要清理一个大房间。传统的垃圾回收方式就像一个人独自清理房间，这样会花很长时间。而并行回收就像是你和几个朋友一起分工合作，同时清理房间。这样清理房间的时间就会大大缩短，你们也可以更快地回到正常活动中。</p></blockquote><h6 id="并行回收的好处"><a href="#并行回收的好处" class="headerlink" title="并行回收的好处"></a><strong>并行回收的好处</strong></h6><ul><li><strong>减少卡顿</strong>：通过分工合作、并行处理，垃圾回收的暂停时间大大减少，应用程序的卡顿现象明显降低。</li><li><strong>提升用户体验</strong>：尤其是在动画播放、游戏或其他需要持续响应的场景中，并行回收可以让用户感觉到应用程序运行更加流畅。</li><li><strong>更高效的资源利用</strong>：充分利用多核处理器的优势，加快垃圾回收的速度，让整个系统的资源使用更为高效。</li></ul><h4 id="增量回收"><a href="#增量回收" class="headerlink" title="增量回收"></a>增量回收</h4><blockquote><p>在 V8 引擎中，虽然并行回收策略已经减少了部分 STW（Stop-The-World，全停顿）现象，但在处理老生代中的大对象时，仍然可能会出现较长的停顿时间。为了解决这一问题，V8 引擎引入了 <strong>增量回收（Incremental Collection）</strong> 策略。增量回收的核心思路是将一次 GC 标记过程分解为许多小步，每执行完一个小步后，应用逻辑得以继续执行一段时间。通过这种交替进行的方式，增量回收能够在完成一轮 GC 标记的同时，显著减少 STW 对程序性能的影响。</p></blockquote><p><img src="https://tuchuang.junsen.online/i/2024/08/18/2hfrv3-2.jpg" alt="1723917018713"></p><h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h4><blockquote><p>三色标记法是一种用于垃圾回收的算法，能够在垃圾回收器随时启动或暂停时，保持标记过程的完整性，并确保不丢失已经标记的结果。该算法使用三种颜色来表示对象的不同状态：白色、灰色和黑色。</p></blockquote><h5 id="规则和流程："><a href="#规则和流程：" class="headerlink" title="规则和流程："></a><strong>规则和流程：</strong></h5><ol><li><strong>初始化</strong>：<ul><li><strong>白色</strong>：初始状态下，所有对象都被标记为白色。白色对象表示尚未访问或处理的对象。</li></ul></li><li><strong>标记开始</strong>：<ul><li>从 <strong>GC Root</strong>（垃圾回收的根对象集合）开始遍历所有可到达的对象，将它们标记为 <strong>灰色</strong>，并放入待处理的队列中。灰色对象表示已经被访问，但其引用的对象尚未全部处理完毕。</li></ul></li><li><strong>处理灰色对象</strong>：<ul><li>从待处理队列中取出一个灰色对象，将它所引用的所有对象标记为灰色，并放入待处理队列。同时，将当前灰色对象标记为 <strong>黑色</strong>。黑色对象表示已经完全处理完毕，它和它引用的对象都不再需要进一步检查。</li></ul></li><li><strong>重复标记</strong>：<ul><li>重复以上步骤，直到灰色对象队列为空。此时，所有存活的对象要么是黑色（已完全处理），要么是灰色（处理中）。当标记完成后，所有未被标记的白色对象即为垃圾对象，可以进行回收。</li></ul></li></ol><h5 id="算法的优势："><a href="#算法的优势：" class="headerlink" title="算法的优势："></a><strong>算法的优势：</strong></h5><ul><li><strong>可暂停和恢复</strong>：垃圾回收器可以根据内存中是否还有灰色对象来判断标记过程是否完成。如果灰色对象队列为空，表示标记过程已完成，可以进行清理工作。如果仍有灰色对象，当垃圾回收器再次启动时，可以从这些灰色对象继续处理，确保标记过程的完整性。</li></ul><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h5><blockquote><p>三色标记法通过颜色标记系统（白、灰、黑）管理对象的状态，确保在垃圾回收过程中，标记可以随时暂停和恢复，且不丢失已经处理的结果。该算法在确保标记准确性的同时，也提高了垃圾回收的灵活性和效率，特别适用于需要频繁暂停和恢复的场景。</p></blockquote><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a><strong>写屏障</strong></h4><blockquote><p>写屏障（Write Barrier）是一种用于垃圾回收器的机制，旨在解决在 JavaScript 代码执行过程中，因对象引用变化而导致标记不准确的问题。特别是在增量标记过程中，写屏障能够确保标记结果的准确性，避免在垃圾回收过程中出现遗漏或错误。</p></blockquote><h5 id="对象引用变化的两种情况："><a href="#对象引用变化的两种情况：" class="headerlink" title="对象引用变化的两种情况："></a><strong>对象引用变化的两种情况：</strong></h5><ol><li><strong>已标记的黑色或灰色对象不再被其他对象引用：</strong><ul><li>这种情况通常不会引发严重问题，因为在下次垃圾回收（GC）过程中，这些对象会重新被标记为白色，并最终被清除掉。</li></ul></li><li><strong>新引入的对象可能是白色对象：</strong><ul><li>新对象最初被标记为白色，而白色对象意味着尚未被访问和标记。如果一个黑色对象（已经完全处理的对象）突然引用了这个白色对象，由于白色对象还没有被标记为存活，它在接下来的垃圾回收中可能会被错误地清除，导致程序异常。</li></ul></li></ol><h5 id="写屏障的工作原理："><a href="#写屏障的工作原理：" class="headerlink" title="写屏障的工作原理："></a><strong>写屏障的工作原理：</strong></h5><ul><li><strong>强制颜色转换</strong>：<ul><li>当系统检测到一个黑色对象开始引用一个白色对象时，写屏障机制会立即将该白色对象标记为灰色。这样一来，白色对象就不会在本轮垃圾回收中被误清除，而是会在下一个标记阶段中被正确处理。</li></ul></li><li><strong>保障标记的准确性</strong>：<ul><li>通过使用写屏障策略，垃圾回收器能够确保在对象引用发生变化时，所有引用关系都能被正确跟踪和更新。这种方式确保了增量标记过程中，引用变动不会影响垃圾回收的准确性。</li></ul></li></ul><h5 id="强三色原则"><a href="#强三色原则" class="headerlink" title="强三色原则"></a><strong>强三色原则</strong></h5><p>这种写屏障机制通常被称为 <strong>强三色原则</strong>。它确保无论何时，只要一个黑色对象引用了一个白色对象，这个白色对象都会被立即标记为灰色，避免它在当前垃圾回收过程中被误清除。</p><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h5><blockquote><p>写屏障在增量标记的垃圾回收过程中起到了关键作用。通过实时更新引用对象的颜色状态，写屏障确保了垃圾回收的准确性和安全性，避免了因对象引用变动而导致的潜在错误。特别是在高性能和复杂应用场景中，写屏障是保障垃圾回收稳定性的重要机制。</p></blockquote><h4 id="惰性清理"><a href="#惰性清理" class="headerlink" title="惰性清理"></a><strong>惰性清理</strong></h4><blockquote><p>在 V8 引擎中，增量标记用于区分活动对象和非活动对象，但真正的内存释放工作则依赖于 <strong>惰性清理（Lazy Sweeping）</strong> 策略。</p></blockquote><h5 id="惰性清理的工作原理："><a href="#惰性清理的工作原理：" class="headerlink" title="惰性清理的工作原理："></a><strong>惰性清理的工作原理：</strong></h5><ul><li><strong>延迟清理</strong>：<ul><li>当增量标记完成后，V8 引擎会判断当前的可用内存是否足以支持 JavaScript 代码的继续执行。如果可用内存充足，那么没有必要立即进行全面的内存清理。相反，V8 会选择将清理过程稍微延迟，让 JavaScript 代码优先执行。</li></ul></li><li><strong>按需清理</strong>：<ul><li>惰性清理允许内存的清理过程按需进行，而不是一次性清理所有非活动对象的内存。V8 会逐步清理这些非活动对象的内存，直到所有需要回收的内存都被释放完毕。</li></ul></li></ul><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h5><blockquote><p>这种策略能够有效平衡内存管理与程序执行的效率，在确保内存资源得到充分利用的同时，减少对 JavaScript 代码执行的中断和影响。通过惰性清理，V8 引擎能够在不影响应用程序性能的前提下，逐步释放内存，优化用户体验。</p></blockquote><h4 id="并发回收"><a href="#并发回收" class="headerlink" title="并发回收"></a><strong>并发回收</strong></h4><blockquote><p><strong>并发回收（Concurrent Collection）</strong> 是一种垃圾回收技术，旨在减少垃圾回收对应用程序主线程执行的干扰，进一步提升应用程序的性能和响应速度。与传统的 STW（Stop-The-World，全停顿）回收方式不同，并发回收允许垃圾回收器在主线程继续执行应用逻辑的同时，利用独立的线程或处理器核心进行垃圾回收任务。</p></blockquote><h5 id="并发回收的工作原理"><a href="#并发回收的工作原理" class="headerlink" title="并发回收的工作原理"></a><strong>并发回收的工作原理</strong></h5><ol><li><strong>分离回收线程</strong>：<ul><li>在并发回收策略中，垃圾回收任务被分配到单独的线程或处理器核心上执行。这意味着主线程可以继续处理用户交互、动画渲染或其他任务，而垃圾回收则在后台悄无声息地进行。</li></ul></li><li><strong>标记并发</strong>：<ul><li>在并发标记阶段，垃圾回收器通过一个独立的线程对内存中的对象进行标记。这种并行处理确保了标记过程不会对主线程产生显著影响，从而减少全停顿时间。</li></ul></li><li><strong>并发清理</strong>：<ul><li>在标记完成后，并发回收器会继续在独立的线程上进行内存的清理和整理工作。因为这些操作都是在后台进行的，主线程几乎不会感知到这些操作，应用程序的执行不会受到明显影响。</li></ul></li><li><strong>处理线程间的同步</strong>：<ul><li>为了确保数据的一致性，并发回收器需要与主线程进行同步，特别是在处理一些对象引用更新或其他关键操作时。V8 引擎采用了高效的同步机制，确保并发回收过程中数据的一致性和正确性。</li></ul></li></ol><h5 id="并发回收的优势"><a href="#并发回收的优势" class="headerlink" title="并发回收的优势"></a><strong>并发回收的优势</strong></h5><ul><li><strong>减少全停顿时间</strong>：<ul><li>并发回收的主要优势在于大幅减少了垃圾回收导致的全停顿时间。应用程序可以在几乎不被打断的情况下继续执行，从而提高了用户体验。</li></ul></li><li><strong>更高的吞吐量</strong>：<ul><li>通过充分利用多核处理器的能力，并发回收能够提高系统的整体吞吐量，让垃圾回收和应用逻辑处理同时进行。</li></ul></li><li><strong>平滑的用户体验</strong>：<ul><li>由于并发回收降低了垃圾回收对应用程序执行的影响，用户感知到的卡顿现象大大减少，特别是在需要持续高响应的应用场景中，例如实时互动和游戏应用。</li></ul></li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h5><blockquote><p>并发回收特别适合于那些对响应时间要求较高的应用场景，例如游戏、实时数据处理、以及高交互性的用户界面。它能够有效避免长时间的卡顿现象，确保应用程序在高负载下依然能够保持流畅的用户体验。</p></blockquote><h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h5><blockquote><p>并发回收通过在独立线程中执行垃圾回收任务，有效减少了垃圾回收对主线程的影响。这种策略不仅提升了应用程序的性能，还显著改善了用户体验，特别是在对实时性要求较高的应用场景中，表现尤为出色。</p></blockquote><h3 id="分代式垃圾回收机制总结"><a href="#分代式垃圾回收机制总结" class="headerlink" title="分代式垃圾回收机制总结"></a><strong>分代式垃圾回收机制总结</strong></h3><blockquote><p>分代式垃圾回收机制通过将内存中的对象划分为 <strong>新生代</strong> 和 <strong>老生代</strong>，大幅提升了垃圾回收的效率</p><ul><li><p><strong>新生代</strong>：存放新创建的、小型的、生命周期较短的对象。由于这些对象的存活时间较短，因此新生代采用了高频率、快速清理的回收策略，使用一小块内存进行频繁的垃圾回收，以快速回收内存。</p></li><li><p><strong>老生代</strong>：存放大对象、生命周期较长或长期存活的对象。老生代中的对象由于已经存活较长时间，不太可能很快被回收，因此回收的频率较低，采用了更复杂和谨慎的回收机制。</p></li></ul><p>V8 引擎通过分代式垃圾回收机制，结合针对新生代和老生代的不同回收算法，优化了内存管理的效率。这种划分使 V8 能够根据对象的生命周期特性，采用最适合的回收策略，从而提高了垃圾回收的效率，减少了内存碎片，并最大限度地降低了垃圾回收对程序性能的影响。</p></blockquote><h2 id="特殊的小知识点"><a href="#特殊的小知识点" class="headerlink" title="特殊的小知识点"></a>特殊的小知识点</h2><ol><li><strong>浏览器垃圾回收与 JavaScript 脚本执行</strong>：<ul><li>当浏览器进行垃圾回收时，JavaScript 脚本的执行会被暂时中断，直到垃圾回收完成后才会继续执行。因此，在高频繁的垃圾回收场景中，优化策略的使用显得尤为重要，以避免不必要的脚本执行延迟。</li></ul></li><li><strong>WeakMap 和 WeakSet</strong>：<ul><li><code>WeakMap</code> 和 <code>WeakSet</code> 是特殊的数据结构，它们的键（对于 <code>WeakMap</code>）或值（对于 <code>WeakSet</code>）不会被垃圾回收机制考虑。这意味着如果没有其他引用指向这些键或值，它们可以被垃圾回收，从而避免内存泄漏。</li></ul></li><li><strong>闭包与内存泄漏</strong>：<ul><li>闭包中的变量是我们需要用到的，因此不会导致内存泄漏。尽管闭包可能会在函数执行完毕后保留对外部变量的引用，但只要这些引用仍然有用，垃圾回收机制就不会回收它们。</li></ul></li></ol><h2 id="容易导致内存泄露的场景"><a href="#容易导致内存泄露的场景" class="headerlink" title="容易导致内存泄露的场景"></a>容易导致内存泄露的场景</h2><ol><li><strong>内存泄露的概念</strong>：<ul><li>内存泄露是指那些「用不到」（无法访问）的变量依然占据着内存空间，无法被垃圾回收机制回收，导致内存无法再利用。</li></ul></li><li><strong>常见场景</strong>：<ul><li><strong>意外的全局变量</strong>：<ul><li>在非严格模式下，如果在函数中未定义的变量会自动创建为全局变量，这会意外地污染全局作用域并导致内存泄露。</li><li><strong>解决方案</strong>：使用严格模式 (<code>&#39;use strict&#39;</code>) 来避免未定义变量变为全局变量。</li></ul></li><li><strong>被遗忘的计时器或回调函数</strong>：<ul><li>如果存在被遗忘的计时器或回调函数，它们的引用不会被垃圾回收机制自动清除，从而导致内存泄露。</li><li><strong>解决方案</strong>：现代浏览器可以检测到此类问题，并在必要时清除这些引用，开发者也应确保及时清理不再需要的计时器和回调。</li></ul></li><li><strong>脱离 DOM 的引用</strong>：<ul><li>将 DOM 元素保存到对象或数组中，而不清除它们的引用，可能导致内存泄露，因为这些引用会持续存在，即使这些 DOM 元素已经从页面上移除。</li><li><strong>解决方案</strong>：确保在不再需要这些 DOM 元素时，及时清除对它们的引用。</li></ul></li></ul></li></ol><h2 id="理解与解决内存泄漏的优化策略"><a href="#理解与解决内存泄漏的优化策略" class="headerlink" title="理解与解决内存泄漏的优化策略"></a>理解与解决内存泄漏的优化策略</h2><h3 id="1-怎么理解内存泄漏？"><a href="#1-怎么理解内存泄漏？" class="headerlink" title="1. 怎么理解内存泄漏？"></a>1. <strong>怎么理解内存泄漏？</strong></h3><blockquote><p>内存泄漏是指程序在运行过程中，分配的内存无法被系统回收利用的情况。具体来说，当程序不再需要某些数据或对象时，这些对象仍然占据着内存空间，导致内存得不到释放。随着时间的推移，内存泄漏会导致系统内存逐渐减少，最终可能导致程序崩溃或性能严重下降。</p></blockquote><h3 id="2-怎么解决内存泄漏？代码层面如何优化？"><a href="#2-怎么解决内存泄漏？代码层面如何优化？" class="headerlink" title="2. 怎么解决内存泄漏？代码层面如何优化？"></a>2. <strong>怎么解决内存泄漏？代码层面如何优化？</strong></h3><h4 id="减少全局变量的使用"><a href="#减少全局变量的使用" class="headerlink" title="减少全局变量的使用"></a><strong>减少全局变量的使用</strong></h4><blockquote><p>全局变量不会被垃圾回收器轻易回收，建议尽量减少全局变量的使用，将变量声明在局部作用域内。</p></blockquote><ul><li><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">不推荐的写法：使用全局变量<br><span class="hljs-keyword">var</span> i, str = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">packageDomGlobal</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        str += i<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 推荐的写法：使用局部变量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">packageDomLocal</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        str += i<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="减少不必要的变量声明"><a href="#减少不必要的变量声明" class="headerlink" title="减少不必要的变量声明"></a><strong>减少不必要的变量声明</strong></h4><blockquote><p>在循环或重复执行的代码中，尽量减少不必要的变量声明，特别是那些值不变的变量，应该提前抽离出来以减少内存消耗。</p></blockquote><ul><li><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 不推荐的写法：每次循环都计算数组长度</span><br><span class="hljs-keyword">var</span> <span class="hljs-title function_">printArray</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;banana&#x27;</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 推荐的写法：提前计算数组长度</span><br><span class="hljs-keyword">var</span> <span class="hljs-title function_">printArray</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;banana&#x27;</span>];<br>  <span class="hljs-keyword">const</span> length = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="清除不再使用的引用"><a href="#清除不再使用的引用" class="headerlink" title="清除不再使用的引用"></a><strong>清除不再使用的引用</strong></h4><blockquote><p>当不再需要某些对象或数据时，确保清除对它们的引用，特别是在 DOM 操作和事件绑定中，要及时解除绑定并移除不再使用的 DOM 元素。</p></blockquote><ul><li><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeElement</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myElement&#x27;</span>);<br>    element.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(element);<br>    element = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清除引用</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="使用性能分析工具"><a href="#使用性能分析工具" class="headerlink" title="使用性能分析工具"></a><strong>使用性能分析工具</strong></h4><p>利用浏览器的 Performance 和 Memory 工具，可以帮助分析和检测内存泄漏问题。通过这些工具，可以查看页面内存使用情况，发现潜在的内存泄漏点，并优化代码以提高性能。</p><ul><li>示例：<ul><li>使用 Chrome 开发者工具的 Memory 面板进行内存快照分析。</li><li>使用 Performance 面板查看 JavaScript 执行时间和内存消耗。</li></ul></li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>内存泄漏是一个需要关注的问题，通过优化代码、减少不必要的全局变量和重复计算，及时清理不再使用的引用，以及使用性能分析工具，可以有效预防和解决内存泄漏，提升应用的稳定性和性能。</p>]]></content>
    
    
    <categories>
      
      <category>前端笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript内功修炼：浏览器事件模型</title>
    <link href="/2024/08/11/JavaScript%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/08/11/JavaScript%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Dom"><a href="#Dom" class="headerlink" title="Dom"></a>Dom</h2><blockquote><p>DOM<code>(Document Object Model</code>，文档对象模型)是针对HTML文档和XML文档的一个API。DOM描绘了一个层次化的节点树，允许开发人员添加、移出和修改页面的某一部分，DOM 脱胎于Netscape 及微软公司创始的 DHTML（动态HTML）。但现在它已经成为表现和操作页面标记的真正跨平台、语言中立的方式。</p><p><code>Netscape Navigator 4</code> 和 <code>IE4</code> 分别发布于 1997 年的 6 月和 10 月发布的 DHTML，由于 <code>IE4</code> 和 <code>Netscape Navigator4</code> 分别支持不同的 DHTML，为了统一标准，W3C开始制定 DOM。1998 年10 月 W3C 总结了 IE 和 Navigator4 的规范，制定了 DOMLevel 1即 DOM1，之前 IE 与 Netscape 的规范则被称为 DOMLevel 0 即 DOM0 。</p></blockquote><h3 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h3><ul><li>文档节点（Document Node）：整棵文档树的根节点。</li><li>元素节点（Element Node）：代表 HTML 或 XML 标签。</li><li>文本节点（Text Node）：元素或属性中的文本内容。</li><li>属性节点（Attribute Node）：元素的属性。</li><li>注释节点（Comment Node）：文档中的注释。</li></ul><h3 id="属性（Attributes）"><a href="#属性（Attributes）" class="headerlink" title="属性（Attributes）"></a>属性（Attributes）</h3><ul><li>可以通过 <code>element.getAttribute(name)</code>、<code>element.setAttribute(name, value)</code> 和 <code>element.removeAttribute(name)</code> 方法来访问和操作元素的属性。</li></ul><h3 id="方法（Methods）"><a href="#方法（Methods）" class="headerlink" title="方法（Methods）"></a>方法（Methods）</h3><ul><li><code>document.getElementById(id)</code>：通过 ID 查找元素。</li><li><code>document.getElementsByClassName(className)</code>：通过类名查找元素。</li><li><code>document.getElementsByTagName(tagName)</code>：通过标签名查找元素。</li><li><code>document.querySelector(selector)</code>：通过 CSS 选择器查找第一个匹配的元素。</li><li><code>document.querySelectorAll(selector)</code>：通过 CSS 选择器查找所有匹配的元素。</li></ul><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><ul><li><code>element.appendChild(newNode)</code>：添加子节点。</li><li><code>element.removeChild(node)</code>：移除子节点。</li><li><code>element.replaceChild(newNode, oldNode)</code>：替换子节点。</li><li><code>element.insertBefore(newNode, referenceNode)</code>：在指定节点前插入新节点。</li></ul><h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><ul><li><code>element.childNodes</code>：获取子节点列表。</li><li><code>element.firstChild</code> 和 <code>element.lastChild</code>：获取第一个和最后一个子节点。</li><li><code>element.parentNode</code>：获取父节点。</li><li><code>element.nextSibling</code> 和 <code>element.previousSibling</code>：获取下一个和上一个兄弟节点。</li></ul><h3 id="事件的基本概念"><a href="#事件的基本概念" class="headerlink" title="事件的基本概念"></a>事件的基本概念</h3><ul><li><strong>事件（Event）</strong>：浏览器中发生的某种动作或事件，比如用户的鼠标点击、键盘输入、页面加载等。</li><li><strong>事件监听器（Event Listener）</strong>：一种函数，用于监听和处理特定类型的事件。</li><li><strong>事件目标（Event Target）</strong>：触发事件的对象，通常是 DOM 元素。</li><li><strong>事件对象（Event Object）</strong>：当事件被触发时，浏览器会生成一个事件对象，包含与事件相关的信息，如事件类型、目标、坐标等。</li></ul><h3 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h3><ul><li><strong>用户界面事件</strong>：如 <code>click</code>、<code>dblclick</code>、<code>mousemove</code>、<code>mouseover</code>、<code>mouseout</code>、<code>mousedown</code>、<code>mouseup</code>、<code>focus</code>、<code>blur</code> 等。</li><li><strong>键盘事件</strong>：如 <code>keydown</code>、<code>keypress</code>、<code>keyup</code>。</li><li><strong>表单事件</strong>：如 <code>submit</code>、<code>change</code>、<code>input</code>、<code>select</code>。</li><li><strong>窗口事件</strong>：如 <code>load</code>、<code>resize</code>、<code>scroll</code>、<code>unload</code>。</li><li><strong>触摸事件</strong>：如 <code>touchstart</code>、<code>touchmove</code>、<code>touchend</code>（在移动设备上使用）。</li></ul><h3 id="DOM0"><a href="#DOM0" class="headerlink" title="DOM0"></a>DOM0</h3><blockquote><p><strong>DOM Level 0</strong> 是早期浏览器支持的一组非标准特性，主要用于简单的动态交互。</p><p><strong>特点</strong>：通过内联事件处理器直接在 HTML 元素上定义事件，不需要通过 JavaScript 代码动态添加事件监听。但是在 IE 中，在使用 DOM0 级方法添加事件处理程序时，event 是作 window 对象的一个属性而存在的。此时访问事件对象需要通过 <code>window.event</code>。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DOM Level 0 Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Button clicked!&#x27;)&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- JavaScript --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);</span><br><span class="language-javascript">    btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"><span class="hljs-comment">// 解除事件绑定</span></span><br><span class="language-javascript">    btn.<span class="hljs-property">onclick</span> = <span class="hljs-literal">null</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="DOM2"><a href="#DOM2" class="headerlink" title="DOM2"></a>DOM2</h3><blockquote><p>W3C 后来将 DOM1 升级为 DOM2，DOM2级规范开始尝试以一种符合逻辑的方式来标准化 DOM事件。DOM0级 可以认为 onclick 是 btn 的一个属性，DOM2级 则将属性升级为队列。</p><p>DOM2级 事件定义了两个方法，用于处理指定和删除事件处理程序的操作，<code>addEventListener()</code>和<code>removeEventListener()</code>，所有的 DOM 节点中都包含这两个方法，它们都接收 3 个参数。</p><ol><li>要处理的事件名；</li><li>作为事件处理程序的函数；</li><li>布尔值，true 代表在捕获阶段调用事件处理程序，false 表示在冒泡阶段调用事件处理程序，默认为 false；</li></ol><p><strong>注意点</strong>：引入了 <code>addEventListener()</code> 方法，支持事件捕获和冒泡。增强了事件模型的灵活性，当dom通过<code>addEventListener()</code>将事件加入到监听队列中，浏览器发现用户点击按钮时，click 队列中依次执行匿名函数，通过<code>addEventListener()</code>添加的事件只能由<code>removeEventListener()</code>来移除，并且<code>removeEventListener()</code>只能移除具名函数，不能移除匿名函数。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DOM Level 2 Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;changeText&quot;</span>&gt;</span>Change Text<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;changeText&#x27;</span>);</span><br><span class="language-javascript">    button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> paragraph = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;demo&#x27;</span>);</span><br><span class="language-javascript">      paragraph.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;Hello, DOM Level 2!&#x27;</span>;</span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//  do something</span><br>&#125;)<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//  do something else</span><br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="IE中-DOM2级事件"><a href="#IE中-DOM2级事件" class="headerlink" title="IE中 DOM2级事件"></a>IE中 DOM2级事件</h3><blockquote><p>IE8 及之前，实现类似<code>addEventListener()</code>和<code>removeEventListener()</code>的两个方法是<code>attachEvent()</code>和<code>detachEvent()</code>，这两个方法接受相同的两个参数。</p><ol><li>要处理的事件名；</li><li>作为事件处理程序的函数；</li></ol><p>IE8 之前的只支持事件冒泡，所以通过<code>attachEvent()</code>添加的事件处理程序只能添加到冒泡阶段。</p><p>当用户点击时，click 队列依次<code>fn1.call(undefined,undefined)</code>，<code>fn2.call(undefined,undefined)</code>。</p><p>类似的<code>detachEvent()</code>也只能移除具名函数，不能移除匿名函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">btn.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;click&#x27;</span>,fn1)<br>btn.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;click&#x27;</span>,fn2)<br></code></pre></td></tr></table></figure><h3 id="dom事件总结"><a href="#dom事件总结" class="headerlink" title="dom事件总结"></a>dom事件总结</h3><blockquote><ol><li>DOM2级的好处是可以添加多个事件处理程序；DOM0对每个事件只支持一个事件处理程序；</li><li>通过DOM2添加的匿名函数无法移除，上面写的例子就移除不了，<code>addEventListener</code>和<code>removeEventListener</code>的handler必须同名；</li><li>作用域：DOM0的handler会在所属元素的作用域内运行，IE的handler会在全局作用域运行，<code>this === window</code>；</li><li>触发顺序：添加多个事件时，DOM2会按照添加顺序执行，IE会以相反的顺序执行；</li><li>跨浏览器的事件处理程序</li></ol></blockquote><h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3><p>事件传播有三个阶段：</p><ul><li><p><strong>捕获阶段（Capture Phase）</strong>：事件从文档的根节点向事件目标传播。</p></li><li><p><strong>目标阶段（Target Phase）</strong>：事件到达事件目标，事件处理器在此阶段执行。</p></li><li><p><strong>冒泡阶段（Bubble Phase）</strong>：事件从事件目标向文档的根节点传播。</p><p><img src="https://tuchuang.junsen.online/i/2024/08/11/qsje4q-2.jpg" alt="1723364402492"></p></li></ul><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><ul><li><p>开发者可以使用 <code>CustomEvent</code> 构造函数创建和触发自定义事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&#x27;myCustomEvent&#x27;</span>, &#123; <span class="hljs-attr">detail</span>: &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;value&#x27;</span> &#125; &#125;);<br>element.<span class="hljs-title function_">dispatchEvent</span>(myEvent);<br></code></pre></td></tr></table></figure></li></ul><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><blockquote><h3 id="事件委托的机制"><a href="#事件委托的机制" class="headerlink" title="事件委托的机制"></a>事件委托的机制</h3><ul><li><strong>事件冒泡</strong>：事件在触发时会从目标元素开始向上传递（冒泡），直到到达 <code>document</code> 或 <code>window</code> 对象。这一过程允许父元素监听子元素的事件。</li><li><strong>目标节点获取</strong>：父节点在事件处理函数中可以通过 <code>event.target</code> 属性获取实际的目标节点，即用户与之交互的子元素。这允许父节点能够识别哪个子元素被点击或触发了事件。</li><li><strong>减少内存消耗</strong>：由于只需要在父节点上绑定一次事件监听器，而不是为每个子节点绑定，减少了浏览器需要管理的事件监听器数量，从而降低内存使用。</li><li><strong>动态元素处理</strong>：当新的子元素动态添加到 DOM 中时，无需为新元素单独设置事件处理程序，因为事件监听器已经在父节点上。这样，新增的子元素会自动受到事件委托机制的影响。</li><li><strong>简化代码</strong>：通过在父节点处理子元素事件，可以集中管理和处理，代码更加简洁和易于维护。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p><strong>复杂性增加</strong>：在事件处理逻辑中，需要通过 <code>event.target</code> 检查和确认事件的实际目标元素，这可能导致代码复杂度增加，尤其是在复杂的 DOM 结构中。</p></li><li><p><strong>事件冒泡的依赖</strong>：事件委托依赖于事件冒泡机制，如果某个子元素使用了 <code>event.stopPropagation()</code> 方法来阻止事件冒泡，那么事件将不会到达父元素，导致事件委托失效。</p></li><li><p><strong>潜在的性能问题</strong>：对于非常大的 DOM 树或高度嵌套的结构，事件冒泡可能会导致性能下降，尽管这种情况在现代浏览器中很少见。</p></li><li><p><strong>不支持某些事件</strong>：某些事件，例如 <code>focus</code> 和 <code>blur</code>，默认不支持冒泡。这意味着这些事件不能被委托，需要使用 <code>focusin</code> 和 <code>focusout</code> 事件替代。</p></li><li><p><strong>延迟事件处理</strong>：由于事件需要冒泡到父元素才被处理，这可能会导致事件响应时间略高于直接在目标元素上处理，尽管通常这种延迟是可以忽略不计的。</p></li><li><p><strong>复杂交互时的调试困难</strong>：当多个事件处理器通过委托方式绑定在父元素上时，调试特定事件处理器可能会比较困难。</p></li></ul><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul><li><p><strong>CSS 样式和伪类的限制</strong>：事件委托不能直接处理与 CSS 伪类相关的事件，例如 <code>:hover</code> 或 <code>:active</code>。这些事件需要通过直接绑定或额外的 JavaScript 逻辑来处理。</p></li><li><p><strong>事件目标不易获取</strong>：在复杂的 DOM 结构中，准确获取 <code>event.target</code> 并验证其属性可能需要额外的代码，这会增加事件处理函数的复杂性。</p></li><li><p><strong>动态变化的 DOM 结构</strong>：虽然事件委托适用于动态添加的元素，但在频繁修改 DOM 结构的场景中，可能需要额外的逻辑来确保事件处理器正常工作。</p></li><li><p><strong>特定业务逻辑的局限性</strong>：对于某些特定的业务逻辑，可能需要在事件处理器中做出复杂的判断和分支处理，导致代码冗长和难以维护。</p></li><li><p><strong>兼容性问题</strong>：某些浏览器或某些事件类型（例如某些旧版本浏览器中的 <code>focus</code> 和 <code>blur</code> 事件）可能不支持事件冒泡，从而影响事件委托的实现。</p></li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Event Delegation Example<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">ul</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">list-style-type</span>: none;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">li</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">cursor</span>: pointer;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;itemList&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 获取 ul 元素</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> itemList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;itemList&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-comment">// 使用事件委托为 ul 添加事件监听器</span></span><br><span class="language-javascript">        itemList.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 检查点击事件的目标是否为 li 元素</span></span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span> &amp;&amp; event.<span class="hljs-property">target</span>.<span class="hljs-property">nodeName</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-comment">// 打印被点击的 li 的文本内容</span></span><br><span class="language-javascript">                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Clicked on: &#x27;</span> + event.<span class="hljs-property">target</span>.<span class="hljs-property">textContent</span>);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="preventDefault与stopPropagation"><a href="#preventDefault与stopPropagation" class="headerlink" title="preventDefault与stopPropagation"></a>preventDefault与stopPropagation</h3><blockquote><p>preventDefault：比如链接被点击会导航到其href指定的URL，这个就是默认行为；</p><p>stopPropagation：立即停止事件在DOM层次中的传播，包括捕获和冒泡事件；</p><p>IE中对应的属性：</p><ul><li>srcElement &#x3D;&gt; target</li><li>returnValue &#x3D;&gt; preventDefaukt()</li><li>cancelBubble &#x3D;&gt; stopPropagation()</li></ul></blockquote><h3 id="事件订阅兼容写法"><a href="#事件订阅兼容写法" class="headerlink" title="事件订阅兼容写法"></a>事件订阅兼容写法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">EventUtil</span> = &#123;<br>  <span class="hljs-comment">// element是当前元素，可以通过getElementById(id)获取</span><br>  <span class="hljs-comment">// type 是事件类型，一般是click ,也有可能是鼠标、焦点、滚轮事件等等</span><br>  <span class="hljs-comment">// handle 事件处理函数</span><br>  <span class="hljs-attr">addHandler</span>: <span class="hljs-function">(<span class="hljs-params">element, type, handler</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 先检测是否存在DOM2级方法,再检测IE的方法，最后是DOM0级方法（一般不会到这）</span><br>    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">addEventListener</span>) &#123;<br>      <span class="hljs-comment">// 第三个参数false表示冒泡阶段</span><br>      element.<span class="hljs-title function_">addEventListener</span>(type, handler, <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">attachEvent</span>) &#123;<br>      element.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">`on<span class="hljs-subst">$&#123;type&#125;</span>`</span>, handler)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      element[<span class="hljs-string">`on<span class="hljs-subst">$&#123;type&#125;</span>`</span>] = handler;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-attr">removeHandler</span>: <span class="hljs-function">(<span class="hljs-params">element, type, handler</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">removeEventListener</span>) &#123;<br>      <span class="hljs-comment">// 第三个参数false表示冒泡阶段</span><br>      element.<span class="hljs-title function_">removeEventListener</span>(type, handler, <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">detachEvent</span>) &#123;<br>      element.<span class="hljs-title function_">detachEvent</span>(<span class="hljs-string">`on<span class="hljs-subst">$&#123;type&#125;</span>`</span>, handler)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      element[<span class="hljs-string">`on<span class="hljs-subst">$&#123;type&#125;</span>`</span>] = <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 获取event对象</span><br>  <span class="hljs-attr">getEvent</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> event ? event : <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span><br>  &#125;,<br>  <span class="hljs-comment">// 获取当前目标</span><br>  <span class="hljs-attr">getTarget</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> event.<span class="hljs-property">target</span> ? event.<span class="hljs-property">target</span> : event.<span class="hljs-property">srcElement</span><br>  &#125;,<br>  <span class="hljs-comment">// 阻止默认行为</span><br>  <span class="hljs-attr">preventDefault</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">preventDefault</span>) &#123;<br>      event.<span class="hljs-title function_">preventDefault</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      event.<span class="hljs-property">returnValue</span> = <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 停止传播事件</span><br>  <span class="hljs-attr">stopPropagation</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (event,stopPropagation) &#123;<br>      event.<span class="hljs-title function_">stopPropagation</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      event.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取元素</span><br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);<br><span class="hljs-comment">// 定义handler</span><br><span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我被点击了&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 监听事件</span><br><span class="hljs-title class_">EventUtil</span>.<span class="hljs-title function_">addHandler</span>(btn, <span class="hljs-string">&#x27;click&#x27;</span>, handler);<br><span class="hljs-comment">// 移除事件监听</span><br><span class="hljs-comment">// EventUtil.removeHandler(button1, &#x27;click&#x27;, clickEvent);</span><br></code></pre></td></tr></table></figure><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><blockquote><p>BOM（Browser Object Model）是浏览器对象模型，它提供了与浏览器窗口进行交互的接口。BOM 不像 DOM 那样是标准化的，但它是现代浏览器实现的一部分，用于控制浏览器的各个方面，如窗口、历史记录、导航等。以下是 BOM 的主要组成部分</p></blockquote><h3 id="Window对象-常用方法和属性"><a href="#Window对象-常用方法和属性" class="headerlink" title="Window对象 - 常用方法和属性"></a>Window对象 - 常用方法和属性</h3><blockquote><p><strong>概述</strong>：<code>window</code> 是 BOM 的核心对象，表示浏览器窗口。所有全局 JavaScript 对象、函数和变量都是 <code>window</code> 的属性。</p></blockquote><ul><li><code>alert(message)</code>: 显示警告框。</li><li><code>confirm(message)</code>: 显示确认框，并返回布尔值。</li><li><code>prompt(message, defaultValue)</code>: 显示提示框，并返回用户输入的字符串。</li><li><code>setTimeout(function, delay)</code>: 设置定时器，执行一次。</li><li><code>setInterval(function, interval)</code>: 设置间隔执行。</li><li><code>clearTimeout(timeoutID)</code>: 清除定时器。</li><li><code>clearInterval(intervalID)</code>: 清除间隔执行。</li><li><code>open(url, name, specs)</code>: 打开新窗口。</li><li><code>close()</code>: 关闭当前窗口。</li></ul><h3 id="Navigator-对象"><a href="#Navigator-对象" class="headerlink" title="Navigator 对象"></a>Navigator 对象</h3><blockquote><p>提供浏览器的信息，常用于检测浏览器类型和版本。</p></blockquote><ul><li><code>navigator.userAgent</code>: 用户代理字符串，包含浏览器信息。</li><li><code>navigator.language</code>: 浏览器的语言设置。</li><li><code>navigator.platform</code>: 操作系统的信息。</li></ul><h3 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h3><blockquote><ul><li><strong>HashRouter</strong>：使用 URL 中的 hash (<code>#</code>) 来保持 UI 和 URL 同步。因此，<code>location.pathname</code> 和 <code>location.search</code> 在这种模式下并不改变，因为 URL 的 hash 部分不会被视为路径或查询字符串的一部分，而是被用于客户端的路由控制。</li><li><strong>BrowserRouter</strong>：使用 HTML5 的历史 API (<code>pushState</code>、<code>replaceState</code>) 来实现路由，因此 <code>location.pathname</code> 和 <code>location.search</code> 可以正常工作，反映 URL 的路径和查询参数。</li></ul><p>在使用 <code>HashRouter</code> 时，只能通过 <code>window.location.hash</code> 来获取 hash 部分的内容，而 <code>BrowserRouter</code> 可以完整地支持路径和查询字符串。</p></blockquote><ul><li><code>location.href</code>: 当前页面的完整 URL。</li><li><code>location.protocol</code>: URL 的协议部分（如 <code>http:</code>）。</li><li><code>location.host</code>: 主机名和端口号。</li><li><code>location.pathname</code>: 路径部分。</li><li><code>location.search</code>: 查询字符串。</li><li><code>location.hash</code>: URL 中的哈希部分。</li><li><code>location.assign(url)</code>: 加载新的文档。</li><li><code>location.reload()</code>: 重新加载当前文档。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Example URL: http://example.com:8080/path/page.html?query=123#section</span><br><br><span class="hljs-comment">// 获取当前页面的完整 URL</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">href</span>); <span class="hljs-comment">// 输出: &quot;http://example.com:8080/path/page.html?query=123#section&quot;</span><br><br><span class="hljs-comment">// 获取 URL 的协议部分</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">protocol</span>); <span class="hljs-comment">// 输出: &quot;http:&quot;</span><br><br><span class="hljs-comment">// 获取主机名和端口号</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">host</span>); <span class="hljs-comment">// 输出: &quot;example.com:8080&quot;</span><br><br><span class="hljs-comment">// 获取路径部分</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">pathname</span>); <span class="hljs-comment">// 输出: &quot;/path/page.html&quot;</span><br><br><span class="hljs-comment">// 获取查询字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">search</span>); <span class="hljs-comment">// 输出: &quot;?query=123&quot;</span><br><br><span class="hljs-comment">// 获取 URL 中的哈希部分</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>); <span class="hljs-comment">// 输出: &quot;#section&quot;</span><br><br><span class="hljs-comment">// 加载新的文档</span><br>location.<span class="hljs-title function_">assign</span>(<span class="hljs-string">&#x27;http://example.com/newpage.html&#x27;</span>);<br><br><span class="hljs-comment">// 重新加载当前文档</span><br>location.<span class="hljs-title function_">reload</span>();<br><br></code></pre></td></tr></table></figure><h3 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h3><blockquote><p>用于操作浏览器的会话历史记录。</p></blockquote><ul><li><code>history.back()</code>: 加载历史记录中的前一个 URL。</li><li><code>history.forward()</code>: 加载历史记录中的下一个 URL。</li><li><code>history.go(n)</code>: 加载相对于当前页面位置的某个 URL，<code>n</code> 可以是正数、负数或零。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">go</span>(-<span class="hljs-number">2</span>); <span class="hljs-comment">// 返回上上页</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>); <span class="hljs-comment">// 返回上一页</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">go</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 刷新当前页</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">go</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 前往下一页</span><br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">back</span>(); <span class="hljs-comment">// 上一页</span><br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">forward</span>(); <span class="hljs-comment">// 下一页</span><br></code></pre></td></tr></table></figure><h3 id="Screen-对象"><a href="#Screen-对象" class="headerlink" title="Screen 对象"></a>Screen 对象</h3><blockquote><p>提供有关用户屏幕的信息。</p></blockquote><ul><li><code>screen.width</code> 和 <code>screen.height</code>: 屏幕的宽度和高度。</li><li><code>screen.availWidth</code> 和 <code>screen.availHeight</code>: 可用屏幕的宽度和高度（不包括任务栏等）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript内功修炼：前端异步编程规范</title>
    <link href="/2024/04/03/JavaScript%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%EF%BC%9A%E5%89%8D%E7%AB%AF%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <url>/2024/04/03/JavaScript%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%EF%BC%9A%E5%89%8D%E7%AB%AF%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="异步编程背景和Promise的引入原因"><a href="#异步编程背景和Promise的引入原因" class="headerlink" title="异步编程背景和Promise的引入原因"></a>异步编程背景和<code>Promise</code>的引入原因</h2><h3 id="异步编程的前置知识"><a href="#异步编程的前置知识" class="headerlink" title="异步编程的前置知识"></a>异步编程的前置知识</h3><blockquote><p>异步编程在JavaScript中出现和发展的原因，主要是由JavaScript的执行环境和其单线程的特性所决定。这里有几个关键点来解释为什么异步编程变得如此重要。</p><ul><li><strong>单线程执行环境</strong><ul><li>JavaScript最初被设计为一种在浏览器中运行的脚本语言，用于添加交互性和动态性。它在设计之初就是单线程的，这意味着在任何给定时刻，JavaScript在同一执行上下文中只能执行一个任务。这种设计简化了事件处理和DOM操作，因为它避免了多线程编程中常见的复杂性，如数据竞争和锁定问题。</li></ul></li><li><strong>非阻塞I&#x2F;O</strong><ul><li>由于JavaScript是单线程的，阻塞式操作（如长时间运行的计算或网络请求）会冻结整个程序，导致不良的用户体验。为了避免这种情况，JavaScript环境提供了非阻塞I&#x2F;O操作，这意味着可以在等待某些操作（如数据从服务器加载）完成时，继续执行其他脚本。</li></ul></li><li><strong>事件循环和回调函数</strong><ul><li>JavaScript利用事件循环和回调函数来实现异步编程。事件循环允许JavaScript代码、事件回调和系统I&#x2F;O等任务在适当的时候从任务队列中被取出执行，而不会阻塞主线程。这种模型支持了异步的回调形式，使得开发者可以编写非阻塞的代码，从而提高应用性能和响应速度。</li></ul></li><li><strong>提高性能和响应性</strong><ul><li>异步编程允许在等待操作完成（如从服务器获取数据）的同时，继续处理用户界面的交互和其他脚本，从而提高了Web应用的性能和响应性。用户不需要等待所有数据都加载完成才能与页面交互，这对于创建流畅的用户体验至关重要。</li></ul></li><li><strong>发展需求</strong><ul><li>随着Web技术的发展和应用越来越复杂，对于更高效、更可靠的异步编程模式的需求也随之增加。这推动了诸如<code>Promise</code>、<code>async/await</code>等新的异步编程模式的出现，使得管理复杂的异步操作和链式调用更加简单和直观。</li></ul></li></ul><p>相关文章：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing">异步 JavaScript 简介</a></li><li><a href="https://yanhaijing.com/javascript/2017/08/02/talk-async/">异步编程那些事</a></li><li><a href="https://www.jeremyjone.com/766/">真丶深入理解JavaScript异步编程（一）：异步</a></li></ul></blockquote><h3 id="Promise的引入原因"><a href="#Promise的引入原因" class="headerlink" title="Promise的引入原因"></a><code>Promise</code>的引入原因</h3><blockquote><p>随着Web应用程序变得越来越复杂，传统的回调方式开始显得力不从心。虽然回调函数提供了一种处理异步操作的手段，但它们也带来了所谓的”回调地狱”（Callback Hell），尤其是在处理多个异步操作时，代码会变得难以理解和维护。因此，为了解决这些问题，<code>Promise</code>应运而生。</p><ul><li><strong>简化异步代码</strong>：<code>Promise</code>提供了一种更优雅的方式来处理异步操作。通过使用<code>Promise</code>，可以避免深层嵌套的回调函数，使代码结构更加清晰和简洁。</li><li><strong>链式调用</strong>：<code>Promise</code>支持链式调用（thenable链），这意味着可以按顺序排列异步操作，而不需要嵌套回调函数。这使得读写代码变得更加直观，也便于理解异步操作的流程。</li><li><strong>错误处理</strong>：在传统的回调模式中，错误处理往往比较复杂且容易出错。<code>Promise</code>通过<code>catch</code>方法提供了一种集中处理错误的机制，使得错误处理更加一致和可靠。</li><li><strong>状态管理</strong>：<code>Promise</code>对象有三种状态：pending（等待中）、fulfilled（已成功）和rejected（已失败）。这种状态管理让异步操作的结果和状态变得可预测，并且只能从<code>pending</code>状态转换到<code>fulfilled</code>或<code>rejected</code>状态，且状态一旦改变就不会再变，这为异步编程提供了更稳定的基础。</li><li><strong>改进的并发控制</strong>：<code>Promise</code>还提供了<code>Promise.all</code>和<code>Promise.race</code>等静态方法，使得并发执行和管理多个异步操作变得更加简单和高效。</li></ul><p><code>Promise</code>的引入是为了解决回调模式中存在的问题，同时提供了一种更强大、更灵活、更易于管理的异步编程解决方案。随后，ES2017标准引入的<code>async/await</code>语法进一步简化了异步操作的编写，但底层机制仍然基于<code>Promise</code>，说明了<code>Promise</code>在现代JavaScript异步编程中的核心地位。</p></blockquote><h2 id="Promise的拆解"><a href="#Promise的拆解" class="headerlink" title="Promise的拆解"></a>Promise的拆解</h2><h3 id="拆解resolve和reject"><a href="#拆解resolve和reject" class="headerlink" title="拆解resolve和reject"></a>拆解resolve和reject</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;fail&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p1&#x27;</span>, p1)<br><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;fail&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p2&#x27;</span>, p2)<br><br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p3&#x27;</span>, p3)<br></code></pre></td></tr></table></figure><p><img src="https://tuchuang.junsen.online/i/2024/04/09/prv98a-2.png" alt="image-20240403155828077"></p><blockquote><p>执行了resolve或者reject后状态会发生改变，分别对应fulfilled和rejected，状态不可逆转，除了Pending状态其他的两个状态只要为其中一个后就不会再发生变更。</p><p>Promise中有throw相当于执行了reject</p></blockquote><h3 id="实现resolve与reject"><a href="#实现resolve与reject" class="headerlink" title="实现resolve与reject"></a>实现resolve与reject</h3><blockquote><p>初始状态为Pending，this指向执行它们的MyPromise实例，防止随着函数执行环境的改变而改变。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一步定义Promise状态</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;pending&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&#x27;rejected&#x27;</span><br><br><span class="hljs-comment">// 第二步</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>    <span class="hljs-comment">// 第三步定义基础属性</span><br>    <span class="hljs-title class_">PromiseState</span>;<br>    <span class="hljs-title class_">PromiseResult</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>        <span class="hljs-comment">// 初始化状态</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initValue</span>()<br>        <span class="hljs-comment">// 第七步执行传进来的函数,在Promise中可以捕获抛出的异常</span><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 有个前提，resolve和reject需要绑定执行它的那个Promise实例</span><br>            <span class="hljs-comment">// 给resolve和reject绑定this</span><br>            <span class="hljs-title function_">executor</span>(<span class="hljs-variable language_">this</span>.#resolve.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>),<span class="hljs-variable language_">this</span>.#reject.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>))<br>        &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>            <span class="hljs-comment">// 如果执行器抛出异常，则调用reject方法，并传入异常</span><br>            <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">reject</span>(error)<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 第四步初始化Promise的状态</span><br>    <span class="hljs-title function_">initValue</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-variable constant_">PENDING</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = <span class="hljs-literal">undefined</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第五步定义统一的状态变更函数</span><br>    #<span class="hljs-title function_">changeStatus</span>(<span class="hljs-params">PromiseStatus, value</span>)&#123;<br>        <span class="hljs-comment">// Promise只有成功或失败，如果状态不是默认的Pending就表明已经变更过了，不能执行后续的代码</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> !== <span class="hljs-variable constant_">PENDING</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-title class_">PromiseStatus</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = value;<br>    &#125;<br><br>    <span class="hljs-comment">// 第六五步定义resolve方法和reject方法</span><br>    #<span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-comment">// 调用Promise状态变更函数</span><br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">changeStatus</span>(<span class="hljs-variable constant_">FULFILLED</span>, value)<br>    &#125;<br><br>    #<span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>)&#123;<br>        <span class="hljs-comment">// 调用Promise状态变更函数</span><br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">changeStatus</span>(<span class="hljs-variable constant_">REJECTED</span>, reason)<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：状态变更</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> test1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test1) <span class="hljs-comment">// MyPromise &#123; PromiseState: &#x27;fulfilled&#x27;, PromiseResult: &#x27;success&#x27; &#125;</span><br><br><span class="hljs-keyword">const</span> test2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;fail&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test2) <span class="hljs-comment">// MyPromise &#123; PromiseState: &#x27;rejected&#x27;, PromiseResult: &#x27;fail&#x27; &#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://tuchuang.junsen.online/i/2024/04/09/prxbiq-2.png" alt="image-20240403162104687"></p><p>测试代码：状态不可变更</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> test1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只以第一次为准</span><br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;fail&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test1) <span class="hljs-comment">// MyPromise &#123; PromiseState: &#x27;fulfilled&#x27;, PromiseResult: &#x27;success&#x27; &#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://tuchuang.junsen.online/i/2024/04/09/pry3jx-2.png" alt="image-20240403162330753"></p><p>测试代码：捕获Promise回调内的异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> test3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span>(<span class="hljs-string">&#x27;fail&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test3) <span class="hljs-comment">// MyPromise &#123; PromiseState: &#x27;rejected&#x27;, PromiseResult: &#x27;fail&#x27; &#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://tuchuang.junsen.online/i/2024/04/09/ps84tj-2.png" alt="image-20240403162451594"></p><h3 id="拆解then方法"><a href="#拆解then方法" class="headerlink" title="拆解then方法"></a>拆解then方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 马上输出 ”success“</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;success&#x27;</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br><br><span class="hljs-comment">// 1秒后输出 ”fail“</span><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;fail&#x27;</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br><br><span class="hljs-comment">// 链式调用 输出 200</span><br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-number">2</span> * res, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res), <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err))<br></code></pre></td></tr></table></figure><p><img src="https://tuchuang.junsen.online/i/2024/04/09/hfmiq6-2.png" alt="image-20240403162635677"></p><blockquote><p>根据上述代码可以确定：</p><ol><li>then接收两个回调，一个是成功回调，一个是失败回调；</li><li>当Promise状态为fulfilled执行成功回调，为rejected执行失败回调；</li><li>如resolve或reject在定时器里，则定时器结束后再执行then；</li><li>then支持链式调用，下一次then执行受上一次then返回值的影响；</li></ol><p>如何实现？</p><ol><li><p>结构和初始化</p><p>首先，<code>MyPromise</code>的构造函数需要接收一个执行器函数，此执行器立即执行，并接收两个参数：<code>resolve</code>和<code>reject</code>。我们需要定义三种状态（<code>pending</code>，<code>fulfilled</code>，<code>rejected</code>），以及用于存储成功&#x2F;失败回调的数组。</p></li><li><p><code>then</code> 方法和状态变更</p><p><code>then</code> 方法应返回一个新的<code>MyPromise</code>对象，以支持链式调用。在<code>then</code>方法中，我们需要检查<code>MyPromise</code>的当前状态，以决定立即执行回调还是将回调存储起来待状态改变后执行。</p><p>对于定时器或异步操作，当<code>resolve</code>或<code>reject</code>在这些操作内部调用时，<code>then</code>注册的回调应在操作完成后执行。这意味着我们需要在状态仍为<code>pending</code>时收集这些回调，并在<code>resolve</code>或<code>reject</code>被调用时按顺序执行它们。</p></li><li><p>链式调用和值的传递</p><p>为了支持链式调用，每次调用<code>then</code>时都应创建并返回一个新的<code>MyPromise</code>对象。这个新的<code>MyPromise</code>对象的解决或拒绝应基于前一个<code>then</code>回调的返回值。</p><p>如果回调函数返回一个值，这个值应传递给链中下一个<code>then</code>的成功回调。如果回调函数抛出异常，则应将异常传递给链中下一个<code>then</code>的失败回调。如果回调函数返回一个新的<code>MyPromise</code>，则该<code>Promise</code>的结果应决定链中下一个<code>then</code>的调用。</p></li></ol></blockquote><h3 id="实现then"><a href="#实现then" class="headerlink" title="实现then"></a>实现then</h3><ul><li><code>#executeCallbacks</code>执行缓存的promise</li><li><code>resolvePromise</code> 处理不同的返回值类型</li><li><code>onFulfilledCallbacks</code>和 <code>onRejectedCallbacks</code> 存储对应状态的执行任务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一步定义Promise状态</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;pending&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&#x27;rejected&#x27;</span><br><br><span class="hljs-comment">// 第二步</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>    <span class="hljs-comment">// 第三步定义基础属性</span><br>    <span class="hljs-title class_">PromiseState</span>;<br>    <span class="hljs-title class_">PromiseResult</span>;<br>    onFulfilledCallbacks = []; <span class="hljs-comment">// 初始化成功回调的存储数组</span><br>    onRejectedCallbacks = []; <span class="hljs-comment">// 初始化失败回调的存储数组</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>        <span class="hljs-comment">// 初始化状态</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initValue</span>()<br>        <span class="hljs-comment">// 第七步执行传进来的函数,在Promise中可以捕获抛出的异常</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 有个前提，resolve和reject需要绑定执行它的那个Promise实例</span><br>            <span class="hljs-comment">// 给resolve和reject绑定this</span><br>            <span class="hljs-title function_">executor</span>(<span class="hljs-variable language_">this</span>.#resolve.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-variable language_">this</span>.#reject.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>))<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-comment">// 如果执行器抛出异常，则调用reject方法，并传入异常</span><br>            <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">reject</span>(error)<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 第四步初始化Promise的状态</span><br>    <span class="hljs-title function_">initValue</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-variable constant_">PENDING</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = <span class="hljs-literal">undefined</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第五步定义统一的状态变更函数</span><br>    #<span class="hljs-title function_">changeStatus</span>(<span class="hljs-params">PromiseState, value</span>) &#123;<br>        <span class="hljs-comment">// Promise只有成功或失败，如果状态不是默认的Pending就表明已经变更过了，不能执行后续的代码</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> !== <span class="hljs-variable constant_">PENDING</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-title class_">PromiseState</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = value;<br><br>        <span class="hljs-comment">// 每次状态变更后都要执行#executeCallbacks方法，根据当前状态执行对应的回调函数</span><br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">executeCallbacks</span>()<br>    &#125;<br><br>    <span class="hljs-comment">// 第六五步定义resolve方法和reject方法</span><br>    #<span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-comment">// 调用Promise状态变更函数</span><br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">changeStatus</span>(<span class="hljs-variable constant_">FULFILLED</span>, value)<br>    &#125;<br><br>    #<span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>        <span class="hljs-comment">// 调用Promise状态变更函数</span><br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">changeStatus</span>(<span class="hljs-variable constant_">REJECTED</span>, reason)<br>    &#125;<br><br>    #<span class="hljs-title function_">executeCallbacks</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 根据当前状态，执行对应的回调函数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-property">length</span>) &#123;<br>                <span class="hljs-comment">// 因为数组本身就和队列的性质一样，通过shift方法可以取出数组中的第一个元素,然后执行里面缓存的回调函数，把当前状态传进去（这里执行的就是存入数组的resolvePromise辅助函数）</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">shift</span>()(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-property">length</span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">shift</span>()(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 第八步定义then方法接收两个回调 onFulfilled, onRejected</span><br>    <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>        <span class="hljs-comment">// 判断是否是函数如果不是包装下返回值为函数</span><br>        onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>        onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;;<br>        <span class="hljs-comment">// 根据上面分析得知，then是支持链式调用，返回的一个包装后的promise对象并且传递给下一个then的成功回调，失败的给失败的</span><br>        <span class="hljs-keyword">const</span> thenPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 通过queueMicrotask来异步执行回调，以确保符合Promise规范的异步行为。这也解决了thenPromise变量作用域的问题，因为handleCallback是在thenPromise被定义之后才使用的。</span><br>            <span class="hljs-comment">// 创建辅助函数resolvePromise</span><br>            <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolvePromise</span> = (<span class="hljs-params">callback, resolve, reject</span>) =&gt; &#123;<br>                <span class="hljs-comment">// 使用js提供的微任务环境，因为then本身就是微任务</span><br>                <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 立即执行传入的onFulfilled或onRejected方法，拿到结果存起来</span><br>                        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>)<br>                        <span class="hljs-comment">// 判断结果是不是和当前返回的promise对象是同一个，如果是则抛出异常，因为循环引用了</span><br>                        <span class="hljs-keyword">if</span> (result &amp;&amp; result === thenPromise) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;循环引用&#x27;</span>);<br>                        &#125;<br>                        <span class="hljs-comment">// 判断当前结果是不是一个Promise对象，如果是则调用then方法，把结果传进去，把then返回的promise对象作为结果返回</span><br>                        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123;<br>                            result.<span class="hljs-title function_">then</span>(resolve, reject)<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-title function_">resolve</span>(result);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                        <span class="hljs-comment">// 拦截thenPromise内部的异常返回回去，然后继续往外抛出</span><br>                        <span class="hljs-title function_">reject</span>(error)<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(error);<br>                    &#125;<br>                &#125;)<br>            &#125;<br><br>            <span class="hljs-comment">// 根据状态处理不同状态的回调函数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>                <span class="hljs-comment">// 如果当前为成功状态，执行第一个回调</span><br>                <span class="hljs-title function_">resolvePromise</span>(onFulfilled, resolve, reject)<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>                <span class="hljs-comment">// 如果当前为失败状态，执行第二个回调</span><br>                <span class="hljs-title function_">resolvePromise</span>(onRejected, resolve, reject)<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>                <span class="hljs-comment">// 如果当前为等待状态，把回调函数存起来，等状态变更后再执行</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolvePromise</span>(onFulfilled, resolve, reject))<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">resolvePromise</span>(onRejected, resolve, reject))<br>            &#125;<br>        &#125;)<br><br>        <span class="hljs-keyword">return</span> thenPromise;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 测试用例 1: 基本的resolve和链式调用</span><br><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;);<br>promise1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 应打印 1</span><br>    <span class="hljs-keyword">return</span> value + <span class="hljs-number">1</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 应打印 2</span><br>&#125;);<br><br><span class="hljs-comment">// 测试用例 2: 使用setTimeout来模拟异步操作</span><br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br>promise2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 1秒后应打印 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">resolve</span>(value + <span class="hljs-number">2</span>);<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 2秒后应打印 4</span><br>&#125;);<br><br><span class="hljs-comment">// 测试用例 3: 错误处理</span><br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Test Error&#x27;</span>);<br>&#125;);<br>promise3.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">message</span>); <span class="hljs-comment">// 应打印 &quot;Test Error&quot;</span><br>&#125;)<br><br></code></pre></td></tr></table></figure><h2 id="queueMicrotask"><a href="#queueMicrotask" class="headerlink" title="queueMicrotask"></a>queueMicrotask</h2><p>相关链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide">queueMicrotask</a></p><blockquote><p>GPT的解释</p><p><code>queueMicrotask</code>是一个在现代浏览器和Node.js环境中内置的全局函数，用于将一个函数安排在所有正在执行的宏任务（例如setTimeout、setInterval、I&#x2F;O操作等）和当前正在执行的微任务（例如Promise的回调）之后、但在下一个宏任务开始之前执行。它提供了一种方式来异步执行代码，而不会延迟到下一个宏任务，从而能够在当前任务和下一个事件循环之间快速地运行一个任务。</p><p><code>queueMicrotask</code>的主要用途是安排微任务（microtask），这是执行异步操作的一种方式，比起宏任务来说，微任务具有更高的优先级。在Promise相关操作中使用<code>queueMicrotask</code>可以确保按照正确的顺序执行异步代码，尤其是在实现自定义Promise或处理与Promise相关的微任务队列时。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Script start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>); <span class="hljs-comment">// 宏任务</span><br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;queueMicrotask&#x27;</span>); <span class="hljs-comment">// 微任务</span><br>&#125;);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise.then&#x27;</span>); <span class="hljs-comment">// 微任务</span><br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Script end&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h3 id="手写queryMicrotask"><a href="#手写queryMicrotask" class="headerlink" title="手写queryMicrotask"></a>手写queryMicrotask</h3><ul><li>写法是渡一袁老师的写法，学习如何实现一个<code>queueMicrotask</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runMicroTask</span>(<span class="hljs-params">runc</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> process === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> process.<span class="hljs-property">nextTick</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// Node.js 环境</span><br>        process.<span class="hljs-title function_">nextTick</span>(runc);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MutationObserver</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 浏览器环境，使用 MutationObserver</span><br>        <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">runc</span>();<br>            observer.<span class="hljs-title function_">disconnect</span>(); <span class="hljs-comment">// 清理，避免重复调用和内存泄漏</span><br>        &#125;);<br>        <span class="hljs-keyword">const</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-title class_">String</span>(counter));<br>        observer.<span class="hljs-title function_">observe</span>(textNode, &#123;<br>            <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span><br>        &#125;);<br>        counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>; <span class="hljs-comment">// 切换值以触发MutationObserver</span><br>        textNode.<span class="hljs-property">data</span> = <span class="hljs-title class_">String</span>(counter);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 作为最后的回退，使用 setTimeout</span><br>        <span class="hljs-built_in">setTimeout</span>(runc, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Promise-A-规范实现"><a href="#Promise-A-规范实现" class="headerlink" title="Promise A+ 规范实现"></a>Promise A+ 规范实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一步定义Promise状态</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;pending&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&#x27;rejected&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPromise</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">return</span> !!(obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 第二步</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>    <span class="hljs-comment">// 第三步定义基础属性</span><br>    <span class="hljs-title class_">PromiseState</span>;<br>    <span class="hljs-title class_">PromiseResult</span>;<br>    onFulfilledCallbacks = []; <span class="hljs-comment">// 初始化成功回调的存储数组</span><br>    onRejectedCallbacks = []; <span class="hljs-comment">// 初始化失败回调的存储数组</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<br>        <span class="hljs-comment">// 初始化状态</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initValue</span>()<br>        <span class="hljs-comment">// 第七步执行传进来的函数,在Promise中可以捕获抛出的异常</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 有个前提，resolve和reject需要绑定执行它的那个Promise实例</span><br>            <span class="hljs-comment">// 给resolve和reject绑定this</span><br>            <span class="hljs-title function_">executor</span>(<span class="hljs-variable language_">this</span>.#resolve.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-variable language_">this</span>.#reject.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>))<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-comment">// 如果执行器抛出异常，则调用reject方法，并传入异常</span><br>            <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">reject</span>(error)<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 第四步初始化Promise的状态</span><br>    <span class="hljs-title function_">initValue</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-variable constant_">PENDING</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = <span class="hljs-literal">undefined</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第五步定义统一的状态变更函数</span><br>    #<span class="hljs-title function_">changeStatus</span>(<span class="hljs-params">PromiseState, value</span>) &#123;<br>        <span class="hljs-comment">// Promise只有成功或失败，如果状态不是默认的Pending就表明已经变更过了，不能执行后续的代码</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> !== <span class="hljs-variable constant_">PENDING</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> = <span class="hljs-title class_">PromiseState</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span> = value;<br><br>        <span class="hljs-comment">// 每次状态变更后都要执行#executeCallbacks方法，根据当前状态执行对应的回调函数</span><br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">executeCallbacks</span>()<br>    &#125;<br><br>    <span class="hljs-comment">// 第六五步定义resolve方法和reject方法</span><br>    #<span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-comment">// 调用Promise状态变更函数</span><br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">changeStatus</span>(<span class="hljs-variable constant_">FULFILLED</span>, value)<br>    &#125;<br><br>    #<span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>        <span class="hljs-comment">// 调用Promise状态变更函数</span><br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">changeStatus</span>(<span class="hljs-variable constant_">REJECTED</span>, reason)<br>    &#125;<br><br>    #<span class="hljs-title function_">executeCallbacks</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 根据当前状态，执行对应的回调函数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-property">length</span>) &#123;<br>                <span class="hljs-comment">// 因为数组本身就和队列的性质一样，通过shift方法可以取出数组中的第一个元素,然后执行里面缓存的回调函数，把当前状态传进去（这里执行的就是存入数组的resolvePromise辅助函数）</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">shift</span>()(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-property">length</span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">shift</span>()(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 第八步定义then方法接收两个回调 onFulfilled, onRejected</span><br>    <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>        <span class="hljs-comment">// 判断是否是函数如果不是包装下返回值为函数</span><br>        onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>        onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;;<br>        <span class="hljs-comment">// 根据上面分析得知，then是支持链式调用，返回的一个包装后的promise对象并且传递给下一个then的成功回调，失败的给失败的</span><br>        <span class="hljs-keyword">const</span> thenPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 通过queueMicrotask来异步执行回调，以确保符合Promise规范的异步行为。这也解决了thenPromise变量作用域的问题，因为handleCallback是在thenPromise被定义之后才使用的。</span><br>            <span class="hljs-comment">// 创建辅助函数resolvePromise</span><br>            <span class="hljs-keyword">const</span> <span class="hljs-title function_">resolvePromise</span> = (<span class="hljs-params">callback, resolve, reject</span>) =&gt; &#123;<br>                <span class="hljs-comment">// 使用js提供的微任务环境，因为then本身就是微任务</span><br>                <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 立即执行传入的onFulfilled或onRejected方法，拿到结果存起来</span><br>                        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseResult</span>)<br>                        <span class="hljs-comment">// 判断结果是不是和当前返回的promise对象是同一个，如果是则抛出异常，因为循环引用了</span><br>                        <span class="hljs-keyword">if</span> (result &amp;&amp; result === thenPromise) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;循环引用&#x27;</span>);<br>                        &#125;<br>                        <span class="hljs-comment">// 判断当前结果是不是一个Promise对象，如果是则调用then方法，把结果传进去，把then返回的promise对象作为结果返回</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPromise</span>(result)) &#123;<br>                            result.<span class="hljs-title function_">then</span>(resolve, reject)<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-title function_">resolve</span>(result);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>                        <span class="hljs-comment">// 拦截thenPromise内部的异常返回回去，然后继续往外抛出</span><br>                        <span class="hljs-title function_">reject</span>(error)<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(error);<br>                    &#125;<br>                &#125;)<br>            &#125;<br><br>            <span class="hljs-comment">// 根据状态处理不同状态的回调函数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>                <span class="hljs-comment">// 如果当前为成功状态，执行第一个回调</span><br>                <span class="hljs-title function_">resolvePromise</span>(onFulfilled, resolve, reject)<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>                <span class="hljs-comment">// 如果当前为失败状态，执行第二个回调</span><br>                <span class="hljs-title function_">resolvePromise</span>(onRejected, resolve, reject)<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">PromiseState</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>                <span class="hljs-comment">// 如果当前为等待状态，把回调函数存起来，等状态变更后再执行</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolvePromise</span>(onFulfilled, resolve, reject))<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolvePromise</span>(onRejected, resolve, reject))<br>            &#125;<br>        &#125;)<br><br>        <span class="hljs-keyword">return</span> thenPromise;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPromiseLike</span>(data)) &#123;<br>                data.<span class="hljs-title function_">then</span>(resolve, reject);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(data);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(reason);<br>        &#125;);<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">promises</span>) &#123;<br>        <span class="hljs-keyword">const</span> result = [];<br>        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-title function_">addData</span> = (<span class="hljs-params">index, value</span>) =&gt; &#123;<br>                result[index] = value;<br>                count++;<br>                <span class="hljs-keyword">if</span> (count === promises.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(result);<br>                &#125;<br>            &#125;<br><br>            promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, index</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPromise</span>(promise)) &#123;<br>                    promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                        <span class="hljs-title function_">addData</span>(index, res);<br>                    &#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">reject</span>(error));<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">addData</span>(index, promise);<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">race</span>(<span class="hljs-params">promises</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">promise</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isPromise</span>(promise)) &#123;<br>                    promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                        <span class="hljs-title function_">resolve</span>(res)<br>                    &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                        <span class="hljs-title function_">reject</span>(err)<br>                    &#125;)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">resolve</span>(promise)<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">allSettled</span>(<span class="hljs-params">promises</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> res = []<br>            <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">const</span> <span class="hljs-title function_">addData</span> = (<span class="hljs-params">status, value, i</span>) =&gt; &#123;<br>                res[i] = &#123;<br>                    status,<br>                    value<br>                &#125;<br>                count++<br>                <span class="hljs-keyword">if</span> (count === promises.<span class="hljs-property">length</span>) &#123;<br>                    <span class="hljs-title function_">resolve</span>(res)<br>                &#125;<br>            &#125;<br>            promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise, i</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isPromise</span>(promise)) &#123;<br>                    promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>                        <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, res, i)<br>                    &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                        <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>, err, i)<br>                    &#125;)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-title function_">addData</span>(<span class="hljs-string">&#x27;fulfilled&#x27;</span>, promise, i)<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">any</span>(<span class="hljs-params">promises</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>            promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">promise</span>) =&gt;</span> &#123;<br>                promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>                    <span class="hljs-title function_">resolve</span>(val)<br>                &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                    count++<br>                    <span class="hljs-keyword">if</span> (count === promises.<span class="hljs-property">length</span>) &#123;<br>                        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(<span class="hljs-string">&#x27;All promises were rejected&#x27;</span>))<br>                    &#125;<br>                &#125;)<br>            &#125;)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">catch</span>(onRejected) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onRejected); <br>    &#125;<br><br>    <span class="hljs-title function_">finally</span>(<span class="hljs-params">onSettled</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<br>            <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>                <span class="hljs-title function_">onSettled</span>();<br>                <span class="hljs-keyword">return</span> data;<br>            &#125;,<br>            <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>                <span class="hljs-title function_">onSettled</span>();<br>                <span class="hljs-keyword">throw</span> reason;<br>            &#125;<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><h3 id="基本的链式调用"><a href="#基本的链式调用" class="headerlink" title="基本的链式调用"></a>基本的链式调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 基本的链式调用</span><br><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;First promise resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: First promise resolved</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Second promise value&#x27;</span>;<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: Second promise value</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="返回新的-Promise-对象"><a href="#返回新的-Promise-对象" class="headerlink" title="返回新的 Promise 对象"></a>返回新的 Promise 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 2 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br>promise2.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: Promise 2 resolved</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Nested Promise resolved&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: Nested Promise resolved</span><br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 3 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br>promise3.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: Promise 3 resolved</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Custom error&#x27;</span>);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error); <span class="hljs-comment">// 输出: Error: Custom error</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="返回新的-Promise-对象，并且处理错误"><a href="#返回新的-Promise-对象，并且处理错误" class="headerlink" title="返回新的 Promise 对象，并且处理错误"></a>返回新的 Promise 对象，并且处理错误</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 4 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br>promise4.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: Promise 4 resolved</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Nested Promise rejected&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error); <span class="hljs-comment">// 输出: Nested Promise rejected</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> promise5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 5 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br>promise5.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(result + <span class="hljs-string">&#x27; with additional data&#x27;</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出: Promise 5 resolved with additional data</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="使用-all-方法"><a href="#使用-all-方法" class="headerlink" title="使用 all 方法"></a>使用 all 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 1 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 2 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 3 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">values</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="使用-any-方法"><a href="#使用-any-方法" class="headerlink" title="使用 any 方法"></a>使用 any 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Promise 4 rejected&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 5 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 6 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-title function_">any</span>([promise4, promise5, promise6]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">errors</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(errors);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="使用-race-方法"><a href="#使用-race-方法" class="headerlink" title="使用 race 方法"></a>使用 race 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise7 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 7 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise8 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 8 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise9 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 9 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-title function_">race</span>([promise7, promise8, promise9]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="使用-allSettled-方法"><a href="#使用-allSettled-方法" class="headerlink" title="使用 allSettled 方法"></a>使用 allSettled 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise10 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 10 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise11 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Promise 11 rejected&#x27;</span>);<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> promise12 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Promise 12 resolved&#x27;</span>);<br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-title function_">allSettled</span>([promise10, promise11, promise12]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript内功修炼：探索原型机制与各类继承模式</title>
    <link href="/2024/04/01/JavaScript%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%EF%BC%9A%E6%8E%A2%E7%B4%A2%E5%8E%9F%E5%9E%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%90%84%E7%B1%BB%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/04/01/JavaScript%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%EF%BC%9A%E6%8E%A2%E7%B4%A2%E5%8E%9F%E5%9E%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%90%84%E7%B1%BB%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript内功修炼：探索原型机制与各类继承模式"><a href="#JavaScript内功修炼：探索原型机制与各类继承模式" class="headerlink" title="JavaScript内功修炼：探索原型机制与各类继承模式"></a>JavaScript内功修炼：探索原型机制与各类继承模式</h1><h2 id="对象的多种创建方式"><a href="#对象的多种创建方式" class="headerlink" title="对象的多种创建方式"></a>对象的多种创建方式</h2><h3 id="字面量创建"><a href="#字面量创建" class="headerlink" title="字面量创建"></a>字面量创建</h3><ul><li>字面量创建时可以直接设定属性（key）和值（value），多个属性通过逗号隔开。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>简洁明了</strong>：使用对象字面量创建对象时，语法简洁明了，易于理解和编写。</li><li><strong>无需额外定义构造函数</strong>：不需要额外定义构造函数，直接通过对象字面量就可以创建对象，省去了定义构造函数的步骤。</li><li><strong>灵活性</strong>：可以直接在对象字面量中定义对象的属性和方法，具有较高的灵活性。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>不利于复用</strong>：对象字面量创建的对象无法直接复用，每次都需要重新定义，无法实现代码的重用。</li><li><strong>不利于封装</strong>：对象字面量创建的对象无法实现属性和方法的封装，所有属性和方法都是公开的，可能会导致数据的安全性问题。</li><li><strong>无法实现继承</strong>：对象字面量创建的对象无法实现真正的继承，无法共享父类的属性和方法，可能会导致代码的冗余。</li><li><strong>无法扩展</strong>：对象字面量创建的对象无法动态添加新的属性和方法，一旦创建完成，就无法再进行修改。</li></ol><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> junsen = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;junsen&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>通过构造函数的形式去生成，例如 Person 构造函数，函数可以接收需要传递给对象的参数，对象的 key 在构造器内部定义。</li></ul><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>可重用性</strong>：可以通过构造函数创建多个具有相同属性和方法的对象，提高代码的重用性。</li><li><strong>封装性</strong>：可以将对象的属性和方法封装在构造函数内部，外部无法直接访问和修改，从而保证数据的安全性。</li><li><strong>可扩展性</strong>：可以在构造函数中添加新的属性和方法，实现对象的扩展和功能的增强。</li><li><strong>易于理解和维护</strong>：构造函数提供了一种清晰的方式来创建对象，使代码易于理解和维护。</li></ol><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>每个对象都会创建新的方法</strong>：使用构造函数创建对象时，每个对象都会拥有一个独立的方法副本，可能会占用较多的内存空间。</li><li><strong>不能共享方法</strong>：由于每个对象都拥有独立的方法副本，无法实现方法的共享，可能会导致代码冗余。</li><li><strong>无法实现继承</strong>：构造函数无法实现真正的继承，每个对象都是独立的实例，无法共享父类的属性和方法。</li></ol><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Junsen&#x27;</span>, <span class="hljs-number">23</span>);<br></code></pre></td></tr></table></figure><h3 id="Object-构造函数"><a href="#Object-构造函数" class="headerlink" title="Object 构造函数"></a>Object 构造函数</h3><ul><li>使用 Object 构造函数创建对象的优缺点如下：</li></ul><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>灵活性</strong>：Object 构造函数允许动态创建对象，并在后续的代码中添加或修改属性和方法。</li><li><strong>适用于动态属性名</strong>：可以在创建对象时使用动态的属性名，从而实现更灵活的对象结构。</li><li><strong>适用于从其他对象继承属性</strong>：可以通过传入其他对象作为参数来继承该对象的属性，实现属性的复用。</li></ol><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>性能相对较低</strong>：与对象字面量相比，使用 Object 构造函数创建对象的性能较低，因为需要执行额外的构造函数调用。</li><li><strong>不直观</strong>：相比于对象字面量，使用 Object 构造函数创建对象可能会显得不够直观和易读，降低了代码的可读性。</li><li><strong>无法添加原型方法</strong>：使用 Object 构造函数创建的对象无法直接添加原型方法，需要通过其他方式实现方法的共享，可能会导致代码的冗余。</li></ol><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj.<span class="hljs-property">key1</span> = value1;<br>obj.<span class="hljs-property">key2</span> = value2;<br></code></pre></td></tr></table></figure><h3 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h3><ul><li>使用工厂函数创建对象的优缺点如下：</li></ul><h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>灵活性</strong>：工厂函数允许根据不同的参数创建不同的对象实例，从而实现对象的灵活性。</li><li><strong>封装性</strong>：工厂函数可以封装对象的创建过程，隐藏对象的内部实现细节，提高代码的封装性。</li><li><strong>代码重用</strong>：可以在工厂函数中实现对象的公共逻辑，从而提高代码的重用性。</li><li><strong>简化对象创建过程</strong>：工厂函数可以简化对象的创建过程，使代码更加清晰和易读。</li></ol><h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>无法实现真正的继承</strong>：工厂函数无法实现真正的继承，每个对象都是独立的实例，无法共享父类的属性和方法。</li><li><strong>无法使用 instanceof 运算符</strong>：由于每个对象都是通过工厂函数创建的，无法使用 instanceof 运算符来判断对象的类型，可能会导致类型判断的困难。</li><li><strong>无法使用原型链</strong>：工厂函数无法使用原型链来实现方法的共享，可能会导致方法的冗余和内存的浪费。</li></ol><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPerson</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    o.<span class="hljs-property">name</span> = name;<br>    o.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span><br><br> o;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-title function_">createPerson</span>(<span class="hljs-string">&#x27;Junsen&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><ul><li>使用 <code>Object.create()</code> 方法创建对象的优缺点如下：</li></ul><h4 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>原型链继承</strong>：<code>Object.create()</code> 方法可以通过指定原型对象来创建新对象，实现原型链继承，使得新对象可以共享原型对象的属性和方法。</li><li><strong>灵活性</strong>：可以通过 <code>Object.create()</code> 方法创建具有不同原型的对象，从而实现更灵活的对象结构。</li><li><strong>简洁性</strong>：相比于传统的构造函数和原型链继承方式，使用 <code>Object.create()</code> 方法创建对象更加简洁明了，代码量更少。</li><li><strong>可继承内置对象</strong>：可以使用 <code>Object.create()</code> 方法创建继承自内置对象的对象，如 <code>Array</code>、<code>Date</code> 等。</li></ol><h4 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>兼容性</strong>：<code>Object.create()</code> 方法是 ES5 中的新特性，不兼容旧版的浏览器，需要使用 polyfill 或者转译成 ES5 兼容的代码。</li><li><strong>需要手动设置原型对象</strong>：使用 <code>Object.create()</code> 方法创建对象时，需要手动设置原型对象，可能会增加一些额外的代码复杂度。</li><li><strong>不能直接添加属性和方法</strong>：使用 <code>Object.create()</code> 方法创建的对象是没有自身属性和方法的，需要通过原型对象来添加属性和方法，可能会增加一些额外的代码复杂度。</li></ol><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br>obj.<span class="hljs-property">key1</span> = value1;<br>obj.<span class="hljs-property">key2</span> = value2;<br></code></pre></td></tr></table></figure><h3 id="class-关键字（ES6）"><a href="#class-关键字（ES6）" class="headerlink" title="class 关键字（ES6）"></a>class 关键字（ES6）</h3><ul><li>使用 <code>class</code> 关键字（ES6）创建对象的优缺点如下：</li></ul><h4 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>语法简洁</strong>：使用 <code>class</code> 关键字可以更清晰地定义对象的结构和行为，代码量更少，可读性更高。</li><li><strong>易于理解</strong>：<code>class</code> 关键字提供了一种面向对象的语法结构，使得代码更加易于理解和维护。</li><li><strong>支持继承</strong>：<code>class</code> 关键字支持通过 <code>extends</code> 关键字实现类的继承，可以更方便地实现对象之间的关系。</li><li><strong>自动添加构造函数</strong>：如果在类中没有定义构造函数，则会自动添加一个默认的构造函数，简化了对象的创建过程。</li><li><strong>支持静态方法和静态属性</strong>：<code>class</code> 关键字支持在类中定义静态方法和静态属性，使得类的功能更加丰富和灵活。</li></ol><h4 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h4><ol><li><strong>兼容性</strong>：<code>class</code> 关键字是 ES6 中的新特性，不兼容旧版的浏览器，需要使用 polyfill 或者转译成 ES5 兼容的代码。</li><li><strong>背后仍然是基于原型的</strong>：尽管使用 <code>class</code> 关键字可以更加直观地编写面向对象的代码，但实际上 JavaScript 仍然是基于原型的语言，<code>class</code> 关键字只是语法糖，背后仍然是基于原型的实现。</li></ol><p>示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Junsen&#x27;</span>, <span class="hljs-number">23</span>);<br></code></pre></td></tr></table></figure><h2 id="JavaScript-参数传递机制（按值传递和共享传递）"><a href="#JavaScript-参数传递机制（按值传递和共享传递）" class="headerlink" title="JavaScript 参数传递机制（按值传递和共享传递）"></a>JavaScript 参数传递机制（按值传递和共享传递）</h2><h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><blockquote><p>什么是按值传递？</p><ul><li>当value通过foo构造器传递参数时，此时内部会重新新建一份一样的数据，然后拷贝过去给新建的，例如下面的代码foo里面有个形参v，这个就是新建的，会把foo(value)的值拷贝给v，我们就算在foo里面修改也不会影响到外面的value。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">v</span>) &#123;<br>    v = <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v); <span class="hljs-comment">//2</span><br>&#125;<br><span class="hljs-title function_">foo</span>(value);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="共享传递"><a href="#共享传递" class="headerlink" title="共享传递"></a>共享传递</h3><blockquote><p>什么是共享传递？</p><ul><li>共享传递是指传递对象时，传递的是当前对象的内存地址，例如下面的第一种方式，传递obj给foo，o接收，此时的o存储的是obj在堆内存中的地址，所以通过o.value可以修改obj的value属性的值，如果按照第二种方式的话，修改的是当前foo里面的o为2了，就把原先指向obj的地址替换为2了，不是修改obj为 2</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 第一种方式</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">o</span>) &#123;<br>    o.<span class="hljs-property">value</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-property">value</span>); <span class="hljs-comment">//2</span><br>&#125;<br><span class="hljs-title function_">foo</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span><br><br><br><span class="hljs-comment">//第二种方式</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">o</span>) &#123;<br>    o = <span class="hljs-number">2</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o); <span class="hljs-comment">//2</span><br>&#125;<br><span class="hljs-title function_">foo</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">value</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>改变前：</p><table><thead><tr><th>栈内存</th><th>堆内存</th><th></th></tr></thead><tbody><tr><td>obj</td><td>指针地址</td><td>{value: 1}</td></tr><tr><td>o</td><td>指针地址</td><td>{value: 1}</td></tr></tbody></table><p>改变后：</p><table><thead><tr><th>栈内存</th><th>堆内存</th><th></th></tr></thead><tbody><tr><td>obj</td><td>指针地址</td><td>{value: 2}</td></tr><tr><td>o</td><td>指针地址</td><td>{value: 2}</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>参数传递传递的是参数的拷贝，如果是引用类型传递进去拷贝的是引用类型的内存地址，如果是常规基础类型的拷贝的是它本身的值</li><li>基本类型存储于栈中，因为它们的值是简单且固定的大小，可以直接在栈上高效地分配和回收。</li><li>引用类型存储于堆内存中，传递时是传递堆内存中的实际值的地址，所以修改o.value就会影响到obj</li></ul><h2 id="继承的多种方式"><a href="#继承的多种方式" class="headerlink" title="继承的多种方式"></a>继承的多种方式</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><ul><li>引用类型的属性被所有实例共享，举个例子：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span> () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Junsen&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">skills</span> = [<span class="hljs-string">&#x27;唱&#x27;</span>,<span class="hljs-string">&#x27;跳&#x27;</span>,<span class="hljs-string">&#x27;rap&#x27;</span>,<span class="hljs-string">&#x27;篮球&#x27;</span>]<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span> () &#123;<br><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// Junsen</span><br><br>child1.<span class="hljs-property">skills</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;写代码&#x27;</span>);<br><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">skills</span>); <span class="hljs-comment">// [&#x27;唱&#x27;，&#x27;跳&#x27;,&#x27;rap&#x27;,&#x27;篮球&#x27;,&#x27;写代码&#x27;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">skills</span>); <span class="hljs-comment">// [&#x27;唱&#x27;，&#x27;跳&#x27;,&#x27;rap&#x27;,&#x27;篮球&#x27;,&#x27;写代码&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="构造器借用"><a href="#构造器借用" class="headerlink" title="构造器借用"></a>构造器借用</h3><ul><li>避免了引用类型的属性被所有实例共享；</li><li>可以在 Child 中向 Parent 传参；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span> (name) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">skills</span> = [<span class="hljs-string">&#x27;唱&#x27;</span>,<span class="hljs-string">&#x27;跳&#x27;</span>,<span class="hljs-string">&#x27;rap&#x27;</span>,<span class="hljs-string">&#x27;篮球&#x27;</span>]<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span> (name) &#123;<br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name);<br>&#125;<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Junsen&#x27;</span>);<br><br>child1.<span class="hljs-property">skills</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;写代码&#x27;</span>);<br><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">skills</span>); <span class="hljs-comment">// [&#x27;唱&#x27;，&#x27;跳&#x27;,&#x27;rap&#x27;,&#x27;篮球&#x27;,&#x27;写代码&#x27;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">skills</span>); <span class="hljs-comment">// [&#x27;唱&#x27;，&#x27;跳&#x27;,&#x27;rap&#x27;,&#x27;篮球&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><ul><li>融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span> (name) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">skills</span> = [<span class="hljs-string">&#x27;唱&#x27;</span>,<span class="hljs-string">&#x27;跳&#x27;</span>,<span class="hljs-string">&#x27;rap&#x27;</span>,<span class="hljs-string">&#x27;篮球&#x27;</span>]<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span> (name) &#123;<br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name); <span class="hljs-comment">// 借用构造器</span><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>(); <span class="hljs-comment">// 原型链继承</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>; <span class="hljs-comment">// 将构造器引用指回来</span><br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Junsen&#x27;</span>);<br><br>child1.<span class="hljs-property">skills</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;写代码&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// Junsen</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">skills</span>); <span class="hljs-comment">// [&#x27;唱&#x27;，&#x27;跳&#x27;,&#x27;rap&#x27;,&#x27;篮球&#x27;,&#x27;写代码&#x27;]</span><br><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;zhangsan&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// zhangsan</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child2.<span class="hljs-property">skills</span>); <span class="hljs-comment">// [&#x27;唱&#x27;，&#x27;跳&#x27;,&#x27;rap&#x27;,&#x27;篮球&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><ul><li>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> parent = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,<br>    <span class="hljs-attr">skills</span>: [<span class="hljs-string">&quot;唱&quot;</span>, <span class="hljs-string">&quot;跳&quot;</span>, <span class="hljs-string">&quot;rap&quot;</span>, <span class="hljs-string">&quot;篮球&quot;</span>],<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent); <span class="hljs-comment">// 使用 parent 对象作为原型创建一个新对象</span><br><br>child.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Junsen&quot;</span>; <span class="hljs-comment">// 修改新对象的属性</span><br>child.<span class="hljs-property">skills</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;写代码&quot;</span>); <span class="hljs-comment">// 修改新对象的属性</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 输出 &quot;Junsen&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">skills</span>); <span class="hljs-comment">// 输出 [&quot;唱&quot;, &quot;跳&quot;, &quot;rap&quot;, &quot;篮球&quot;, &quot;写代码&quot;]</span><br><br><span class="hljs-keyword">var</span> anotherChild = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent); <span class="hljs-comment">// 创建另一个子对象</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anotherChild.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 输出 &quot;Parent&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anotherChild.<span class="hljs-property">skills</span>); <span class="hljs-comment">// 输出 [&quot;唱&quot;, &quot;跳&quot;, &quot;rap&quot;, &quot;篮球&quot;, &quot;写代码&quot;]</span><br><br></code></pre></td></tr></table></figure><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原型对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span> (name) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">skills</span> = [<span class="hljs-string">&#x27;唱&#x27;</span>,<span class="hljs-string">&#x27;跳&#x27;</span>,<span class="hljs-string">&#x27;rap&#x27;</span>,<span class="hljs-string">&#x27;篮球&#x27;</span>]<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><br><span class="hljs-comment">// 寄生式继承的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObj</span>(<span class="hljs-params">o</span>)&#123;<br>    <span class="hljs-keyword">var</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(o);<br>    clone.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> clone;<br>&#125;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-title function_">createObj</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>(<span class="hljs-string">&quot;Junsen&quot;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 输出 &quot;Junsen&quot;</span><br>instance.<span class="hljs-title function_">say</span>(); <span class="hljs-comment">// 输出 &quot;hi&quot;</span><br></code></pre></td></tr></table></figure><h3 id="寄生组合式"><a href="#寄生组合式" class="headerlink" title="寄生组合式"></a>寄生组合式</h3><ul><li>寄生组合式继承是一种常用的继承方式，它继承了组合继承的优点，并避免了它的缺点, 寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">skills</span> = [<span class="hljs-string">&#x27;唱&#x27;</span>,<span class="hljs-string">&#x27;跳&#x27;</span>,<span class="hljs-string">&#x27;rap&#x27;</span>,<span class="hljs-string">&#x27;篮球&#x27;</span>];<br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name); <span class="hljs-comment">// 第一次调用父类构造函数，继承属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 继承原型方法，避免第二次调用父类构造函数</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>; <span class="hljs-comment">// 修正constructor指向</span><br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getAge</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;Junsen&#x27;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 输出 &quot;Junsen&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-title function_">getAge</span>()); <span class="hljs-comment">// 输出 23</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child1.<span class="hljs-property">skills</span>); <span class="hljs-comment">// 输出 [&#x27;唱&#x27;,&#x27;跳&#x27;,&#x27;rap&#x27;,&#x27;篮球&#x27;]</span><br><br></code></pre></td></tr></table></figure><h2 id="new操作符的实现原理"><a href="#new操作符的实现原理" class="headerlink" title="new操作符的实现原理"></a>new操作符的实现原理</h2><ol><li>创建一个空对象。</li><li>将这个空对象的<code>[[Prototype]]</code>（也称为原型）链接到构造函数的<code>prototype</code>属性。</li><li>将这个空对象作为<code>this</code>上下文来调用构造函数。</li><li>如果构造函数没有显式返回一个对象，则返回这个新创建的对象。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params">constructor, ...args</span>) &#123;<br>    <span class="hljs-comment">// 创建一个空对象</span><br>    <span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>    <span class="hljs-comment">// 将这个空对象的原型链接到构造函数的prototype属性</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    <span class="hljs-comment">// 将这个空对象作为this上下文来调用构造函数</span><br>    <span class="hljs-keyword">let</span> result = constructor.<span class="hljs-title function_">apply</span>(obj, args);<br>    <span class="hljs-comment">// 如果构造函数没有显式返回一个对象，则返回这个新创建的对象</span><br>    <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? result : obj;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">objectFactory</span>(<span class="hljs-title class_">Person</span>,<span class="hljs-string">&#x27;Junsen&#x27;</span>,<span class="hljs-number">18</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">// Person &#123;name: &#x27;Junsen&#x27;, age: 18&#125;</span><br></code></pre></td></tr></table></figure><h2 id="this-call-apply-bind"><a href="#this-call-apply-bind" class="headerlink" title="this&#x2F;call&#x2F;apply&#x2F;bind"></a>this&#x2F;call&#x2F;apply&#x2F;bind</h2><h3 id="对this对象的理解"><a href="#对this对象的理解" class="headerlink" title="对this对象的理解"></a>对this对象的理解</h3><ul><li><p>this是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this的指向可以通过四种调用模式来判断</p><ol><li>函数调用模式：当函数作为普通函数调用时，<code>this</code> 指向全局对象。</li><li>方法调用模式：当函数作为对象的方法调用时，<code>this</code> 指向这个对象。</li><li>构造器调用模式：当函数使用 <code>new</code> 关键字调用时，<code>this</code> 指向新创建的对象。</li><li>apply、call 和 bind 调用模式：这些方法可以显式地指定函数执行时的 <code>this</code> 指向。</li></ol></li><li><p>这些模式的优先级按照下面的顺序排列：构造器调用模式 &gt; apply、call 和 bind 调用模式 &gt; 方法调用模式 &gt; 函数调用模式。</p></li></ul><h3 id="call-和-apply-，bind-的区别"><a href="#call-和-apply-，bind-的区别" class="headerlink" title="call() 和 apply() ，bind()的区别"></a>call() 和 apply() ，bind()的区别</h3><blockquote><p><code>call()</code>、<code>apply()</code> 和 <code>bind()</code> 都是用来改变函数中的 <code>this</code> 指向的方法，它们之间有一些区别：</p></blockquote><h4 id="参数传递方式："><a href="#参数传递方式：" class="headerlink" title="参数传递方式："></a>参数传递方式：</h4><ul><li><code>call()</code> 和 <code>apply()</code> 的主要区别在于传入参数的方式。<code>call()</code> 方法传入的参数数量不固定，从第二个参数开始依次传入函数作为参数；而 <code>apply()</code> 方法接受两个参数，第一个参数指定了函数体内 <code>this</code> 对象的指向，第二个参数为一个数组或类数组对象，这些元素会作为参数传递给被调用的函数。</li><li>举个例子，假设有一个函数 <code>foo</code>，如果想在调用时将 <code>this</code> 指向 <code>obj</code> 对象，并传入参数 <code>a</code> 和 <code>b</code>，可以这样调用：<ul><li>使用 <code>call()</code>：<code>foo.call(obj, a, b)</code></li><li>使用 <code>apply()</code>：<code>foo.apply(obj, [a, b])</code></li></ul></li></ul><h4 id="立即调用与延迟调用："><a href="#立即调用与延迟调用：" class="headerlink" title="立即调用与延迟调用："></a>立即调用与延迟调用：</h4><ul><li><code>call()</code> 和 <code>apply()</code> 是立即调用的，它们会立即执行函数，并且改变函数中的 <code>this</code> 指向。</li><li><code>bind()</code> 则是延迟调用的，它会创建一个新的函数，并将指定的 <code>this</code> 对象绑定到新函数上，但不会立即执行。新函数可以在之后任意的时间点被调用，并且 <code>this</code> 的指向会保持绑定。</li></ul><h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h4><ul><li><code>call()</code> 和 <code>apply()</code> 在调用函数后会立即返回函数执行的结果。</li><li><code>bind()</code> 返回一个新的函数，不会立即执行原函数，而是返回一个绑定了指定上下文的新函数，需要调用这个新函数才会执行原函数。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><code>call()</code> 和 <code>apply()</code> 可以实现立即的函数调用，并且可以传入不同形式的参数，而 <code>bind()</code> 则是创建一个新的函数，将指定的 <code>this</code> 对象绑定到新函数上，之后可以在任意时间点调用这个新函数，并且 <code>this</code> 的指向会保持绑定。</p><h3 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h3><ul><li>call函数的实现步骤<ol><li><strong>检查调用对象</strong>：首先，要检查调用 <code>call()</code> 方法的对象是否是一个函数，因为只有函数才能调用 <code>call()</code> 方法。如果不是函数，则抛出类型错误。</li><li><strong>获取参数</strong>：从 <code>arguments</code> 对象中获取除了第一个参数（即要绑定的 <code>this</code> 对象）之外的所有参数，这些参数会作为调用函数的参数。</li><li><strong>确定调用对象</strong>：判断传入的 <code>this</code> 对象是否为 <code>undefined</code> 或 <code>null</code>，如果是，则将其设置为全局对象（在浏览器环境下是 <code>window</code>）。</li><li><strong>绑定函数</strong>：将调用 <code>call()</code> 方法的函数设置为传入的 <code>this</code> 对象的一个属性，以便后续调用。</li><li><strong>调用函数</strong>：通过设置的 <code>this</code> 对象来调用函数，并传入参数。</li><li><strong>获取返回值</strong>：如果函数有返回值，可以将其保存下来，以便后续返回。</li><li><strong>清理环境</strong>：调用完函数后，删除在 <code>this</code> 对象上设置的函数属性，以保持环境的清洁。</li><li><strong>返回结果</strong>：返回函数执行的结果。</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否是函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h3><ul><li>apply函数的实现步骤<ol><li><strong>检查调用对象</strong>：首先，要检查调用 <code>apply()</code> 方法的对象是否是一个函数，如果不是函数，则抛出类型错误。</li><li><strong>确定上下文对象</strong>：判断传入的上下文对象是否存在，如果不存在，则将其设置为全局对象 <code>window</code>。</li><li><strong>绑定函数</strong>：将调用 <code>apply()</code> 方法的函数设置为传入的上下文对象的一个属性。</li><li><strong>判断参数</strong>：判断传入的参数数组是否存在，如果不存在，则设置为空数组。</li><li><strong>调用函数</strong>：使用上下文对象来调用这个方法，并传入参数数组。</li><li><strong>获取返回值</strong>：如果函数有返回值，保存返回结果。</li><li><strong>清理环境</strong>：调用完函数后，删除在上下文对象上设置的函数属性。</li><li><strong>返回结果</strong>：返回函数执行的结果。</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context, argsArray</span>) &#123;<br>  <span class="hljs-comment">// 1. 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;The object is not callable&#x27;</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 2. 判断传入上下文对象是否存在，如果不存在，则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <br>  <span class="hljs-comment">// 3. 将函数作为上下文对象的一个属性</span><br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-title class_">Symbol</span>();<br>  context[fn] = <span class="hljs-variable language_">this</span>;<br>  <br>  <span class="hljs-comment">// 4. 判断参数值是否传入</span><br>  argsArray = argsArray || [];<br>  <br>  <span class="hljs-comment">// 5. 使用上下文对象来调用这个方法，并保存返回结果</span><br>  <span class="hljs-keyword">const</span> result = context[fn](...argsArray);<br>  <br>  <span class="hljs-comment">// 6. 删除刚才新增的属性</span><br>  <span class="hljs-keyword">delete</span> context[fn];<br>  <br>  <span class="hljs-comment">// 7. 返回结果</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h3><ul><li>bind函数的实现步骤<ol><li><strong>检查调用对象是否为函数</strong>：首先，要检查调用 <code>bind()</code> 方法的对象是否是一个函数，如果不是函数，则抛出类型错误。</li><li><strong>确定绑定对象</strong>：将传入的 <code>this</code> 对象保存到变量 <code>self</code> 中，以便后续调用。</li><li><strong>获取参数</strong>：从剩余参数 <code>...args</code> 中获取传入的参数数组，如果没有传入参数，则设置为空数组。</li><li><strong>返回新函数</strong>：创建一个新的函数，并在函数内部将传入的参数和新函数调用时的参数合并，然后调用原函数，并绑定指定的上下文对象。</li><li><strong>返回结果</strong>：返回新函数。</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...args</span>) &#123;<br>  <span class="hljs-comment">// 1. 检查调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;The object is not callable&#x27;</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 2. 确定绑定对象</span><br>  <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br>  <br>  <span class="hljs-comment">// 3. 获取参数</span><br>  args = args || [];<br>  <br>  <span class="hljs-comment">// 4. 返回新函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...innerArgs</span>) &#123;<br>    <span class="hljs-comment">// 将固定的参数和新函数调用时传入的参数合并</span><br>    <span class="hljs-keyword">const</span> allArgs = args.<span class="hljs-title function_">concat</span>(innerArgs);<br>    <span class="hljs-comment">// 调用原函数，并绑定上下文对象</span><br>    <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">apply</span>(context, allArgs);<br>  &#125;;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript内功修炼：编译原理、执行上下文与作用域链全方位实战解析</title>
    <link href="/2024/03/17/JavaScript%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%EF%BC%9A%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AE%9E%E6%88%98%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/03/17/JavaScript%E5%86%85%E5%8A%9F%E4%BF%AE%E7%82%BC%EF%BC%9A%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%85%A8%E6%96%B9%E4%BD%8D%E5%AE%9E%E6%88%98%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript内功修炼：编译原理、执行上下文与作用域链全方位实战解析"><a href="#JavaScript内功修炼：编译原理、执行上下文与作用域链全方位实战解析" class="headerlink" title="JavaScript内功修炼：编译原理、执行上下文与作用域链全方位实战解析"></a>JavaScript内功修炼：编译原理、执行上下文与作用域链全方位实战解析</h1><p>尽管通常将 JavaScript 视为“动态”或“解释型”语言，但它不同于传统预编译语言之处在于，JavaScript 代码不是提前编译的，且编译结果不能直接移植到其他环境。JavaScript被归类为“动态”或“解释执行”语言，主要是由于以下两个方面的特点：</p><ol><li>动态类型系统：在 JavaScript 中，变量的类型可以在运行时动态改变。例如，变量 <code>num</code> 可以先初始化为数字 <code>1</code>，然后重新赋值为字符串 <code>&quot;1&quot;</code>。这与静态类型语言（如 Java）中变量声明时即确定类型的机制不同，在 JavaScript 中，变量内存大小由其当前存储的值决定而非声明时指定。</li><li>解释执行：JavaScript 引擎逐行解释并执行代码，而不是像 C++ 或 Java 那样先编译成机器码再执行。这种特性允许代码在运行时被修改和执行，如通过 <code>eval()</code> 函数执行字符串形式的 JavaScript 代码片段。</li></ol><h3 id="编译流程概览"><a href="#编译流程概览" class="headerlink" title="编译流程概览"></a>编译流程概览</h3><h4 id="分词-词法分析（Tokenizing-Lexing）"><a href="#分词-词法分析（Tokenizing-Lexing）" class="headerlink" title="分词&#x2F;词法分析（Tokenizing&#x2F;Lexing）"></a>分词&#x2F;词法分析（Tokenizing&#x2F;Lexing）</h4><p>词法分析是编译过程的第一步，它将源代码分解为一系列有意义的基本单元——词法单元（tokens），比如关键字、标识符、运算符、数字等。例如，对于表达式 <code>var a = 2;</code>，词法分析器会识别出 <code>&#39;var&#39;</code>、<code>&#39;a&#39;</code>、<code>&#39;=&#39;</code> 和 <code>&#39;;&#39;</code> 等词法单元。</p><h4 id="解析-语法分析（Parsing）"><a href="#解析-语法分析（Parsing）" class="headerlink" title="解析&#x2F;语法分析（Parsing）"></a>解析&#x2F;语法分析（Parsing）</h4><p>解析阶段将词法单元流转换为抽象语法树（Abstract Syntax Tree, AST）。AST 是一个结构化的树形数据模型，表示程序的语法结构。以 <code>var a = 2;</code>为例，对应的 AST 中包含一个顶层节点 <code>VariableDeclaration</code>，下级有 <code>Identifier</code>（<code>a</code>）节点和 <code>AssignmentExpression</code> 节点，后者又有一个子节点 <code>NumericLiteral</code>（值为 <code>2</code>）。AST 描述了代码的逻辑层次关系，便于后续编译或解释阶段使用。</p><h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>代码生成阶段将 AST 转换为可执行代码。对于给定的语句 <code>var a = 2;</code>，目标是在执行时创建变量 <code>a</code>，分配内存，并将数值 <code>2</code> 存储至该内存地址中。JavaScript 引擎不仅在执行前进行编译，还会进行即时编译（JIT）、延迟编译等多种优化手段来提升性能。</p><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><ul><li>构造函数（constructor）：构造函数是用于创建对象的特殊函数，通过 <code>new</code> 关键字调用来创建新的对象，并将对象的原型指向构造函数的原型（prototype）。</li><li>原型（prototype）：每个对象都具有一个特殊属性 <code>__proto__</code>，指向该对象的构造函数的原型对象。构造函数的 <code>prototype</code> 属性则指向了该构造函数创建的所有实例对象的原型对象。</li><li>原型链（prototype chain）：原型链是通过对象的 <code>__proto__</code> 属性构成的链式结构，用于实现对象之间的继承关系。当访问对象的属性时，JavaScript 引擎会沿着原型链向上查找，直到找到匹配的属性或者到达原型链的顶端（即 <code>Object.prototype</code>）为止。</li><li>总结：<ol><li>构造函数通过 <code>prototype</code> 属性指向原型对象，对象通过 <code>__proto__</code> 属性指向构造函数的原型对象，这构成了原型链。当访问对象属性时，如果原型链查找到顶部仍未找到，则返回 <code>null</code>。</li><li><strong>Function函数是所有函数的祖先函数：</strong><code>Function</code> 函数是 JavaScript 中所有函数的祖先函数，因为所有函数都是由 <code>Function</code> 构造函数创建的。</li><li><strong>所有构造函数都有一个 prototype 属性：</strong> 所有构造函数都具有一个 <code>prototype</code> 属性，这个属性指向了该构造函数创建的所有实例对象的原型对象。</li><li><strong>所有原型对象都有一个 constructor 属性：</strong> 所有原型对象都具有一个 <code>constructor</code> 属性，指向其对应的构造函数。</li><li><strong>所有函数都是对象：</strong> 在 JavaScript 中，函数也是一种对象。函数可以被赋值给变量，作为对象的属性，传递给函数等，因此它们也是对象的一种。</li><li><strong>所有对象都有一个 <code>__proto__</code> 属性：</strong> 所有对象都具有一个 <code>__proto__</code> 属性，它指向了该对象的原型对象。这个属性构成了原型链的基础。</li></ol></li></ul><p>​<img src="https://tuchuang.junsen.online/i/2024/03/18/3c041e-2.png" alt="image-20240316135952389"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;&#125;<br><br><span class="hljs-comment">// prototype是实例原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Junsen&quot;</span>;<br><br><span class="hljs-comment">// 实例对象</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);<br><span class="hljs-comment">// 实例对象person的__proto__指向实例原型Person.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-comment">// Person构造函数与prototype的桥梁是constructor</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);<br><br><span class="hljs-comment">// Person的__proto__指向 Function.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-comment">// Person实例原型的__proto__指向 Object.prototyp</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-comment">// Function.prototype.constructor指向 Function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Function</span>);<br><br><span class="hljs-comment">// Function的__proto__ 指向 Function的实例原型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-comment">// Function实例原型的__proto__ 指向 Object.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-comment">// Object的__proto__又指向 Function的实例原型prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-comment">// Object实例原型的contructor指向Object</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>);<br><br><span class="hljs-comment">// Object实例原型指向null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h2 id="执行上下文与作用域"><a href="#执行上下文与作用域" class="headerlink" title="执行上下文与作用域"></a>执行上下文与作用域</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul><li>先进后出后进先出（LIFO）</li><li><strong>动态创建和销毁：</strong> 每当代码开始执行时，js引擎都会创建一个新的执行上下文，并将其推入执行上下文栈的顶部。当代码执行完毕后出栈</li><li><strong>执行上下文栈管理：</strong>执行上下文以堆栈的形式组织，被称为执行上下文栈或者调用栈。栈的特效保证了执行上下文的正确管理和代码执行顺序的维护。</li><li><strong>变量提升：</strong>在执行上下文中，变量和函数声明都会被提升到作用域顶部，这被称为变量提升。这意味着可以在声明前访问变量和函数。</li><li><strong>作用域链接：</strong>每个执行上下文都有一个词法环境，包含了当前作用域的变量和函数声明，同时也引用了外部执行的上下文词法环境，形成作用于链。作用域链决定了变量和函数的查找顺序，</li><li><strong>闭包的产生：</strong> 作用域链的存在使得内部函数可以访问外部的函数的变量，从而形成了闭包，闭包可以保留对其词法作用域的引用，使得函数可以在定义的作用域之外执行，并且仍然可以访问定义时的变量。</li><li><strong>变量和函数的生命周期：</strong> 变量和函数的生命周期与其所在的执行上下文相关联。在执行上下文被销毁时，其中的变量和函数也会被销毁，释放内存空间。</li></ul><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><ul><li>代码从上到下执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo1&#x27;</span>);<br><br>&#125;<br><br><span class="hljs-title function_">foo</span>();  <span class="hljs-comment">// foo1</span><br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo2&#x27;</span>);<br><br>&#125;<br><br><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// foo2</span><br></code></pre></td></tr></table></figure><h4 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h4><ul><li>全局代码（Global code）：全局代码是指全局作用域中执行的代码，即不包含在任何函数内部的代码。当程序启动时，会先执行全局代码。全局代码可以包含变量声明、函数声明、以及其他可执行语句。</li><li>函数代码（Function code）：函数代码是指在函数内部定义的代码块。每当函数调用时，都会创建一个新的执行上下文（Execution Context），并执行函数代码。函数代码可以包含变量声明、语句、和其他函数的定义等。</li><li>eval代码（Eval code）：当使用 <code>eval</code> 函数执行字符串作为 JavaScript 代码时，该代码会被动态解析和执行，并插入到当前执行上下文中。然而，由于 <code>eval</code> 具有动态性，可能导致代码执行的不可预测性和安全性问题，因此应该谨慎使用。</li><li>总结：在 JavaScript 中，可执行代码（executable code）主要分为三种类型：全局代码（global code）、函数代码（function code）和 eval 代码。</li></ul><h4 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h4><ul><li>执行上下文栈（Execution Context Stack）是JavaScript引擎用来管理执行上下文的数据结构。它是一个栈，用于存储当前执行代码的执行上下文。</li><li>每当代码开始执行时都会创新一个新的上下文，并将其推入执行上下文栈的顶部。</li><li>当代码执行完成后，对应的执行执行上下文就会被弹出栈。这种先进后出的方式确保了执行上下文的正确管理，保证了代码的执行顺序。</li><li>执行上下文栈主要的作用是跟踪代码执行的过程中的上下文信息，包含变量、作用域链、this指向等、通过执行上下文栈，JavaScript引擎能够在代码执行过程中准确地确定变量和函数的作用域，以及各种执行环境的关系。</li></ul><h3 id="作用域是什么？"><a href="#作用域是什么？" class="headerlink" title="作用域是什么？"></a>作用域是什么？</h3><blockquote><p>作用域是 JavaScript 中管理变量可见性和生命周期的规则集合。它决定了变量在哪里可以被访问以及何时创建和销毁。作用域链的概念保证了在嵌套的作用域中正确查找变量，而闭包正是由于作用域链的存在，使得内部函数能够访问外部函数的变量，即使在外部函数执行完毕后仍然能够保持对外部变量的引用。</p></blockquote><h4 id="执行上下文栈的模拟"><a href="#执行上下文栈的模拟" class="headerlink" title="执行上下文栈的模拟"></a>执行上下文栈的模拟</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义执行上下文对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutionContext</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义执行上下文栈</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutionContextStack</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [];<br>    &#125;<br><br>    <span class="hljs-comment">// 推入执行上下文</span><br>    <span class="hljs-title function_">push</span>(<span class="hljs-params">context</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(context);<br>    &#125;<br><br>    <span class="hljs-comment">// 弹出执行上下文</span><br>    <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">pop</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前栈顶执行上下文</span><br>    <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取执行上下文栈的大小</span><br>    <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// case 1</span><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>();<br>&#125;<br><span class="hljs-title function_">checkscope</span>();<br><br><span class="hljs-comment">// 创建全局上下文栈实例</span><br><span class="hljs-keyword">const</span> ecs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContextStack</span>();<br><br><span class="hljs-comment">// 模拟执行上下文的创建和销毁过程</span><br>ecs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&#x27;Global&#x27;</span>)) <span class="hljs-comment">// 创建全局执行上下文推入栈中</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkScope</span>(<span class="hljs-params"></span>)&#123;<br>    ecs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&#x27;checkScope&#x27;</span>)); <span class="hljs-comment">//创建 checkScope 函数执行上下文并推入栈中</span><br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        ecs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&#x27;f&#x27;</span>)); <span class="hljs-comment">//创建f函数执行上下文并推入栈中</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;current context:&#x27;</span>,ecs.<span class="hljs-title function_">peek</span>().<span class="hljs-property">name</span>); <span class="hljs-comment">// 打印当前执行上下文的名称</span><br>        ecs.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 弹出栈顶执行上下文</span><br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">f</span>();<br>    ecs.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 弹出栈顶执行上下文</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">checkScope</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Return value：&quot;</span>, result);<br></code></pre></td></tr></table></figure><ul><li>总结：在这个案例中，<code>checkScope</code>函数被调用后会立即执行，并且在执行过程中会创建一个新的执行上下文<code>checkScope</code>。在<code>checkScope</code>中又定义了个<code>f</code>函数，并且在<code>f</code>函数中访问了外部函数<code>checkScope</code>的scope变量。由于JavaScript的词法作用域规则，<code>f</code>函数在查找变量时会首先查找自身函数的作用域，如果没有就会向上查找,所以获取到了checkScope的scope。因此<code>f</code>函数返回的scope是checkScope的scope值，即<code>local scope</code></li></ul><h5 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// case 2</span><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-title function_">checkscope</span>()();<br><br><br><span class="hljs-comment">// 创建执行上下文栈实例</span><br><span class="hljs-keyword">const</span> ecs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContextStack</span>();<br><br><span class="hljs-comment">// 模拟执行上下文的创建销毁过程</span><br>ecs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&#x27;Global&#x27;</span>)); <span class="hljs-comment">// 创建全局执行上下文并推入栈中</span><br><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkScope</span>(<span class="hljs-params"></span>)&#123;<br>    ecs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&#x27;checkScope&#x27;</span>)); <span class="hljs-comment">// 创建checkScope的执行上下文并推入栈</span><br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;local scope&#x27;</span>;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        ecs.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&#x27;f&#x27;</span>)); <span class="hljs-comment">//创建f函数的执行上下文并推入栈中</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Current context：&#x27;</span>, ecs.<span class="hljs-title function_">peek</span>().<span class="hljs-property">name</span>); <span class="hljs-comment">//打印当前执行上下文的名称</span><br>        ecs.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">//弹出栈顶的执行上下文</span><br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <br>    <span class="hljs-keyword">const</span> result = f;<br>    ecs.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 弹出栈顶执行上下文</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">checkScope</span>()();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Return value:&#x27;</span>,result);<br></code></pre></td></tr></table></figure><ul><li>这个案例中，<code>checkScope</code>函数被调用后返回一个内部定义的函数 <code>f</code>。此时并没有立即执行<code>f</code>函数，而是将其作为值通过return返回出去给外部调用。因此外部调用<code>checkScope()()</code>时，实际上是在执行返回的<code>f</code>函数。由于词法作用域的规则，<code>f</code>函数在查找变量时仍会按照静态作用域的规则向上查找外部的作用域。所以返回的结果是<code>local scope</code>。</li></ul><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li>在这两个案例中，不同的是第一个是<code>Global上下文</code>、<code>checkScope上下文</code>、<code>f上下文</code>的入栈执行，然后<code>f上下文</code>、<code>checkScope上下文</code>、<code>Global上下文</code>的顺序出栈，第二个案例f函数作为返回值返回来。在外部调用<code>checkScope</code>时然后再调用<code>f</code>函数,所以它们的出入栈顺序是 Global上下文，<code>checkScope</code>上下文，此时<code>checkScope</code>上下文已经执行完毕出栈，但是<code>f</code>函数又被调用了，此时<code>f</code>函数入栈继续执行，执行完毕后出栈，才到<code>Global上下文</code>出栈</li></ul><h2 id="变量对象与作用域链"><a href="#变量对象与作用域链" class="headerlink" title="变量对象与作用域链"></a>变量对象与作用域链</h2><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><ul><li><p>JavaScript中的“变量对象”是执行上下文“Execution Context”中用来存储变量和函数声明的内部数据结构，在代码执行过程中起着重要的作用，用来管理变量和函数的创建、访问和执行。</p><ul><li><strong>创建阶段：</strong> 在此阶段，变量对象被创建，并且在变量对象中存储了所有的变量和函数声明。但是这个阶段中，变量和函数声明的实际赋值操作并没执行。</li><li><strong>执行阶段：</strong> 在此阶段，JavaScript引擎会逐行执行代码，并按照代码的顺序对变量对象中的变量进行赋值操作。</li></ul><p>变量对象包含以下内容：</p><ul><li><strong>函数参数：</strong> 在函数上下文中，函数的参数会被存储在变量对象中，每个参数都会被作为变量对象的属性，属性名为参数名，属性值为传入的参数值。如果调用函数时没有提供参数，则对应的属性值为undefined。</li><li><strong>函数声明：</strong> 在函数上下文中，通过function关键字声明的函数会被整体存储在变量对象中。函数声明会被视为变量对象的属性，属性名为函数名，属性值为对应的函数对象。如果变量对象已经存在相同名称的属性，则会完全替换该属性，以最新声明的函数为准。</li><li><strong>变量声明：</strong> 在函数上下文中，通过var关键字声明的变量会被存储在变量对象中。变量声明会被视为变量对象的属性，属性名为变量名，属性值为undefined。如果变量名与已经声明的形式参数或函数名相同，则变量声明不会干扰已经存在的这类属性，即不会覆盖已存在的属性。</li></ul></li></ul><blockquote><p>Vo（Variable Object）和Ao（Activation Object）是早期ECMAScript规范中使用的术语，用于描述执行上下文中变量对象的不同阶段。它们本质上都是同一个东西，只是表现得状态不一样。</p><ul><li>Vo（Variable Object）：这是执行上下文进入创建阶段时生成的内部数据结构，它包含了所有变量声明和函数声明。在这个阶段，只记录变量名和函数声明而不进行实际赋值。</li><li>Ao（Activation Object）：当代码开始执行，即进入执行阶段时，激活对象作为动态生成的对象出现，它用于存储变量的实际值以及对函数引用的访问。Ao是对变量对象的一种扩展，在现代JavaScript引擎中，这个概念通常不再明确区分，而是统一为执行上下文中的一个单一变量对象，并随着执行过程逐步填充变量的实际值。</li></ul><p>在现代JavaScript引擎中，激活对象已经不再是一个显式的概念，而是被整合到执行上下文中的变量对象中。</p></blockquote><h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br>  b = <span class="hljs-number">3</span>;<br><br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);<br><br>在进入执行上下文后，这时候的 <span class="hljs-variable constant_">AO</span> 是：<br><span class="hljs-variable constant_">AO</span> = &#123;<br>    <span class="hljs-attr">arguments</span>: &#123;<br>        <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>    &#125;,<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,<br>    <span class="hljs-attr">c</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>    <span class="hljs-attr">d</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><ul><li>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">AO</span> = &#123;<br>    <span class="hljs-attr">arguments</span>: &#123;<br>        <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>    &#125;,<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-attr">c</span>: reference to <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>)&#123;&#125;,<br>    <span class="hljs-attr">d</span>: reference to <span class="hljs-title class_">FunctionExpression</span> <span class="hljs-string">&quot;d&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>全局上下文的变量对象初始化</strong>：全局上下文的变量对象初始化为全局对象，即全局变量和全局函数都会成为全局对象的属性。</li><li><strong>函数上下文的变量对象初始化</strong>：函数上下文的变量对象初始化只包括 <code>arguments</code> 对象，用于存储传入函数的参数信息。</li><li><strong>进入执行上下文时的变量对象初始化</strong>：在进入执行上下文时，会给变量对象添加形参、函数声明、变量声明等初始的属性值。形参作为属性名，对应的值为传入的参数值；函数声明和变量声明作为属性名，对应的值分别为函数引用和 <code>undefined</code>。</li><li><strong>代码执行阶段的变量对象更新</strong>：在代码执行阶段，会根据代码的逐行执行，对变量对象的属性值进行修改和更新。函数和变量的赋值操作会更新变量对象中对应属性的值。</li></ul><h3 id="自定义Ecs模拟"><a href="#自定义Ecs模拟" class="headerlink" title="自定义Ecs模拟"></a>自定义Ecs模拟</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义执行上下文对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutionContext</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">variableObject</span> = &#123;&#125;; <span class="hljs-comment">// 变量对象</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">scopeChain</span> = []; <span class="hljs-comment">// 作用域链</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">thisValue</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// this</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义执行上下文栈</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutionContextStack</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span> = [];<br>    &#125;<br><br>    <span class="hljs-comment">// 推入执行上下文</span><br>    <span class="hljs-title function_">push</span>(<span class="hljs-params">context</span>) &#123;<br>        <span class="hljs-comment">// 更新作用域链</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            context.<span class="hljs-property">scopeChain</span> = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">scopeChain</span>, context.<span class="hljs-property">variableObject</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            context.<span class="hljs-property">scopeChain</span> = [context.<span class="hljs-property">variableObject</span>];<br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">push</span>(context);<br>        <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;stack&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;context&#x27;</span>,context);<br>    &#125;<br><br>    <span class="hljs-comment">// 弹出执行上下文</span><br>    <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;stack&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-title function_">pop</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前栈顶执行上下文</span><br>    <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取执行上下文栈的大小</span><br>    <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">stack</span>.<span class="hljs-property">length</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Case1-1"><a href="#Case1-1" class="headerlink" title="Case1"></a>Case1</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>; <span class="hljs-comment">// 声明一个全局变量 scope，赋值为 &quot;global scope&quot;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// 定义函数 checkscope</span><br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>; <span class="hljs-comment">// 声明一个局部变量 scope，赋值为 &quot;local scope&quot;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// 定义内部函数 f</span><br>        <span class="hljs-keyword">return</span> scope; <span class="hljs-comment">// 返回当前作用域中的 scope 变量的值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(); <span class="hljs-comment">// 调用内部函数 f 并返回其结果</span><br>&#125;<br><span class="hljs-title function_">checkscope</span>(); <span class="hljs-comment">// 调用函数 checkscope</span><br><br><span class="hljs-comment">// 创建全局上下文栈实例</span><br><span class="hljs-keyword">const</span> ecs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContextStack</span>();<br><br><span class="hljs-comment">// 创建全局执行上下文</span><br><span class="hljs-keyword">const</span> globalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&quot;global&quot;</span>); <span class="hljs-comment">// 创建全局执行上下文对象，名称为 &quot;global&quot;</span><br>globalContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">scope</span> = <span class="hljs-string">&quot;global scope&quot;</span>; <span class="hljs-comment">// 将全局变量 scope 的值设置为 &quot;global scope&quot;</span><br>ecs.<span class="hljs-title function_">push</span>(globalContext)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;current context:&quot;</span>,ecs.<span class="hljs-title function_">peek</span>().<span class="hljs-property">name</span>); <span class="hljs-comment">// 打印当前执行上下文的名称</span><br><br><span class="hljs-comment">//创建checkScope函数执行上下文。</span><br><span class="hljs-keyword">const</span> checkScopeContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&quot;checkscope&quot;</span>); <span class="hljs-comment">// 创建 checkscope 函数执行上下文对象，名称为 &quot;checkscope&quot;</span><br>checkScopeContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">scope</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 在 checkscope 函数执行上下文中，变量对象中的 scope 属性为 undefined</span><br>checkScopeContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">arguments</span> = &#123;<span class="hljs-attr">length</span>: <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 在 checkscope 函数执行上下文中，变量对象中的 arguments 属性为一个对象，表示没有传入参数</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkScope</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// 定义函数 checkScope</span><br>    ecs.<span class="hljs-title function_">push</span>(checkScopeContext); <span class="hljs-comment">// 将 checkScope 函数执行上下文推入执行上下文栈中，表示进入了 checkScope 函数的执行过程</span><br>checkScopeContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">scope</span> = <span class="hljs-string">&quot;local scope&quot;</span>; <span class="hljs-comment">// 将局部变量 scope 的值设置为 &quot;local scope&quot;，表示进入了 checkScope 函数内部的执行过程</span><br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;local scope&#x27;</span>; <span class="hljs-comment">// 声明一个局部变量 scope，赋值为 &quot;local scope&quot;</span><br>    <span class="hljs-comment">// 创建 f 函数执行上下文</span><br>    <span class="hljs-keyword">const</span> fContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&quot;f&quot;</span>); <span class="hljs-comment">// 创建内部函数 f 的执行上下文对象，名称为 &quot;f&quot;</span><br>    fContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">scope</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 在 f 函数执行上下文中，变量对象中的 scope 属性为 undefined</span><br>    fContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">arguments</span> = &#123;<span class="hljs-attr">length</span>: <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 在 f 函数执行上下文中，变量对象中的 arguments 属性为一个对象，表示没有传入参数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// 定义内部函数 f</span><br>        ecs.<span class="hljs-title function_">push</span>(fContext); <span class="hljs-comment">// 将 f 函数执行上下文推入执行上下文栈中，表示进入了 f 函数的执行过程</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;current context:&quot;</span>,ecs.<span class="hljs-title function_">peek</span>().<span class="hljs-property">name</span>); <span class="hljs-comment">// 打印当前执行上下文的名称</span><br>        ecs.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 弹出栈顶执行上下文，表示退出了 f 函数的执行过程</span><br>        <span class="hljs-keyword">return</span> scope; <span class="hljs-comment">// 返回当前作用域中的 scope 变量的值</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">f</span>(); <span class="hljs-comment">// 调用内部函数 f，并将结果保存在 result 变量中</span><br>    ecs.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 弹出栈顶执行上下文，表示退出了 checkScope 函数的执行过程</span><br>    <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回函数执行结果</span><br>&#125;<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">checkScope</span>(); <span class="hljs-comment">// 调用函数 checkScope，并将结果保存在 result 变量中</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Return value:&#x27;</span>,result); <span class="hljs-comment">// 打印函数执行结果</span><br><br></code></pre></td></tr></table></figure><h4 id="Case2-1"><a href="#Case2-1" class="headerlink" title="Case2"></a>Case2</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>; <span class="hljs-comment">// 声明一个全局变量 scope，赋值为 &quot;global scope&quot;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// 定义函数 checkscope</span><br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>; <span class="hljs-comment">// 声明一个局部变量 scope，赋值为 &quot;local scope&quot;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// 定义内部函数 f</span><br>        <span class="hljs-keyword">return</span> scope; <span class="hljs-comment">// 返回当前作用域中的 scope 变量的值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> f; <span class="hljs-comment">// 调用内部函数 f 并返回其结果</span><br>&#125;<br><span class="hljs-title function_">checkscope</span>()(); <span class="hljs-comment">// 调用函数 checkscope</span><br><br><span class="hljs-comment">// 创建全局上下文栈实例</span><br><span class="hljs-keyword">const</span> ecs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContextStack</span>();<br><br><span class="hljs-comment">// 创建全局执行上下文</span><br><span class="hljs-keyword">const</span> globalContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&quot;global&quot;</span>); <span class="hljs-comment">// 创建全局执行上下文对象，名称为 &quot;global&quot;</span><br>globalContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">scope</span> = <span class="hljs-string">&quot;global scope&quot;</span>; <span class="hljs-comment">// 将全局变量 scope 的值设置为 &quot;global scope&quot;</span><br>ecs.<span class="hljs-title function_">push</span>(globalContext)<br><span class="hljs-comment">//创建checkScope函数执行上下文。</span><br><span class="hljs-keyword">const</span> checkScopeContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&quot;checkscope&quot;</span>); <span class="hljs-comment">// 创建 checkscope 函数执行上下文对象，名称为 &quot;checkscope&quot;</span><br>checkScopeContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">scope</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 在 checkscope 函数执行上下文中，变量对象中的 scope 属性为 undefined</span><br>checkScopeContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">arguments</span> = &#123;<span class="hljs-attr">length</span>: <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 在 checkscope 函数执行上下文中，变量对象中的 arguments 属性为一个对象，表示没有传入参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkScope</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">// 定义函数 checkScope</span><br>    ecs.<span class="hljs-title function_">push</span>(checkScopeContext); <span class="hljs-comment">// 将 checkScope 函数执行上下文推入执行上下文栈中，表示进入了 checkScope 函数的执行过程</span><br>checkScopeContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">scope</span> = <span class="hljs-string">&quot;local scope&quot;</span>; <span class="hljs-comment">// 将局部变量 scope 的值设置为 &quot;local scope&quot;，表示进入了 checkScope 函数内部的执行过程</span><br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;local scope&#x27;</span>; <span class="hljs-comment">// 声明一个局部变量 scope，赋值为 &quot;local scope&quot;</span><br>    <span class="hljs-comment">// 创建 f 函数执行上下文</span><br>    <span class="hljs-keyword">const</span> fContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>(<span class="hljs-string">&quot;f&quot;</span>); <span class="hljs-comment">// 创建内部函数 f 的执行上下文对象，名称为 &quot;f&quot;</span><br>    fContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">scope</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 在 f 函数执行上下文中，变量对象中的 scope 属性为 undefined</span><br>    fContext.<span class="hljs-property">variableObject</span>.<span class="hljs-property">arguments</span> = &#123;<span class="hljs-attr">length</span>: <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 在 f 函数执行上下文中，变量对象中的 arguments 属性为一个对象，表示没有传入参数</span><br>   <br>     <span class="hljs-comment">// 定义内部函数 f</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>        ecs.<span class="hljs-title function_">push</span>(fContext); <span class="hljs-comment">// 将 f 函数执行上下文推入执行上下文栈中，表示进入了 f 函数的执行过程</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;current context:&quot;</span>,ecs.<span class="hljs-title function_">peek</span>().<span class="hljs-property">name</span>); <span class="hljs-comment">// 打印当前执行上下文的名称</span><br>        ecs.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 弹出栈顶执行上下文，表示退出了 f 函数的执行过程</span><br>        <span class="hljs-keyword">return</span> scope; <span class="hljs-comment">// 返回当前作用域中的 scope 变量的值</span><br>    &#125;<br>    ecs.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 弹出栈顶执行上下文，表示退出了 checkScope 函数的执行过程</span><br>    <span class="hljs-keyword">return</span> f; <span class="hljs-comment">// 返回函数执行结果</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ecs&#x27;</span>,ecs.<span class="hljs-title function_">size</span>())<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">checkScope</span>()();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Return value:&#x27;</span>,result); <span class="hljs-comment">// 打印函数执行结果</span><br><br><br></code></pre></td></tr></table></figure><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>在 JavaScript 中，作用域链是理解变量访问规则的关键概念之一。简单来说，作用域链决定了在代码执行过程中如何查找变量。下面是对作用域链的优化解释：</p><ol><li><strong>ES6 前后的变量声明方式</strong>：<ul><li>在 ES6 之前，我们使用 <code>var</code> 关键字声明变量时，它们会被提升到所在函数作用域的顶部，而没有块级作用域的概念。这意味着变量的作用域由函数的边界确定。</li><li>ES6 引入了 <code>let</code> 和 <code>const</code> 关键字，它们允许我们在任意代码块（比如 <code>&#123;&#125;</code>）内创建变量，从而引入了块级作用域的概念。这让我们更加灵活地管理变量的作用域范围。</li></ul></li><li><strong>作用域链的形成</strong>：<ul><li>作用域链并不仅仅是由大括号的嵌套关系决定的，而是由函数的嵌套关系决定的。在 JavaScript 中，函数内部可以访问外部的变量，这导致了作用域链的形成。</li><li>每当 JavaScript 引擎执行代码时，会创建一个执行上下文，并按照函数的嵌套关系形成作用域链。作用域链的顶部是当前执行代码的作用域，然后依次向上查找，直到找到变量或达到全局作用域。</li></ul></li><li><strong>作用域链的查找规则</strong>：<ul><li>JavaScript 引擎按照就近原则从当前作用域开始查找变量。如果在当前作用域找不到变量，则会依次向上层作用域查找，直到找到变量或者达到全局作用域为止。</li></ul></li><li><strong>全局作用域的特殊性</strong>：<ul><li>全局作用域是所有函数作用域的外层作用域。这是因为 JavaScript 引擎在执行代码时首先创建一个全局执行上下文，其中包含了整个代码的执行环境。函数在定义时会捕获所在的作用域链，因此可以访问外部的变量。</li></ul></li></ol><blockquote><p>总之，作用域链决定了 JavaScript 中变量的访问规则，而理解作用域链对于编写高质量的 JavaScript 代码至关重要。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 全局作用域</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;global&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 一级作用域</span><br>    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;outer&quot;</span>;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">// 二级作用域</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 在这里访问变量 x</span><br>    &#125;<br><br>    <span class="hljs-title function_">fn2</span>(); <span class="hljs-comment">// 调用 fn2 函数</span><br>&#125;<br><br><span class="hljs-title function_">fn1</span>(); <span class="hljs-comment">// 调用 fn1 函数</span><br><br></code></pre></td></tr></table></figure><p>在这个例子中，我们在不同的作用域中定义了同名的变量 <code>x</code>。现在让我们来看一下执行时的作用域链：</p><ol><li>在 <code>fn2</code> 函数内部，我们尝试访问变量 <code>x</code>。由于 <code>fn2</code> 内部并没有定义变量 <code>x</code>，JavaScript 引擎会沿着作用域链向上查找。</li><li>在 <code>fn2</code> 函数的外部（即 <code>fn1</code> 函数内部），我们定义了变量 <code>x</code>，其值为 <code>&quot;outer&quot;</code>。因此，JavaScript 引擎在这一级找到了变量 <code>x</code>，并将其值打印出来。</li><li>如果在 <code>fn1</code> 函数内部也没有定义变量 <code>x</code>，JavaScript 引擎会继续向上查找，最终到达全局作用域。在全局作用域中，我们定义了变量 <code>x</code>，其值为 <code>&quot;global&quot;</code>。</li></ol><p>所以，最终输出的结果将会是 <code>&quot;outer&quot;</code>，因为在作用域链中，<code>fn2</code> 函数可以访问到 <code>fn1</code> 函数内部定义的变量 <code>x</code>，而不是全局作用域中的变量 <code>x</code>。</p><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>在浏览器执行 JavaScript 代码时，首先进行的是预解析（Hoisting），这是一个重要的步骤。预解析阶段并不是直接执行代码，而是对代码进行加工处理，以便后续的逐行执行。</p><p>在预解析阶段，主要有以下几个规则：</p><ol><li><strong>变量和函数声明提升</strong>：<ul><li>使用 <code>var</code> 关键字声明的变量以及函数声明会被提升到当前作用域的顶部。这意味着变量和函数可以在它们被声明之前被引用。</li><li>使用 <code>let</code> 和 <code>const</code> 关键字声明的变量不会被提升，它们只能在声明后才能被访问。</li></ul></li><li><strong>变量与函数同名时的处理</strong>：<ul><li>如果在同一个作用域内，既有变量又有函数使用了相同的名称，那么函数声明会优先于变量声明被提升到作用域顶部。</li><li>这意味着在预解析阶段，同名函数会覆盖同名变量的声明，因此在预解析后，该名称会被认定为函数。</li></ul></li><li><strong>代码的顺序保持不变</strong>：<ul><li>在进行预解析后，虽然变量和函数的声明被提升到了作用域顶部，但是原始代码的书写顺序不会改变。预解析只是将声明提升到了最顶部，而不会改变代码的执行顺序。</li></ul></li></ol><p>总的来说，预解析是 JavaScript 在执行之前对代码进行的一种预处理，它确保了变量和函数的声明在执行时可以被正确地访问。理解预解析对于理解 JavaScript 的执行机制是非常重要的。</p><h3 id="预解析练习1"><a href="#预解析练习1" class="headerlink" title="预解析练习1"></a>预解析练习1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">var</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-title function_">fun</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">456</span>;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> var num;</span><br><span class="hljs-comment"> function fun()&#123;</span><br><span class="hljs-comment">    var num;</span><br><span class="hljs-comment">    console.log(num); undefined</span><br><span class="hljs-comment">    num = 456;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">num = 123;</span><br><span class="hljs-comment">fun();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="预解析练习2"><a href="#预解析练习2" class="headerlink" title="预解析练习2"></a>预解析练习2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">666</span>;<br><span class="hljs-title function_">test</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">777</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c);<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">888</span>;<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-number">999</span>;<br>&#125;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">var a;</span><br><span class="hljs-comment">function test()&#123;</span><br><span class="hljs-comment">    var b;</span><br><span class="hljs-comment">    var a;</span><br><span class="hljs-comment">    b = 777;</span><br><span class="hljs-comment">    console.log(a); undefined</span><br><span class="hljs-comment">    console.log(b); 777</span><br><span class="hljs-comment">    console.log(c); 报错</span><br><span class="hljs-comment">    a = 888;</span><br><span class="hljs-comment">    let c = 999;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">a = 666;</span><br><span class="hljs-comment">test() */</span><br></code></pre></td></tr></table></figure><h3 id="预解析练习3"><a href="#预解析练习3" class="headerlink" title="预解析练习3"></a>预解析练习3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;demo() 1&#x27;</span>);<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;demo() 2&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-title function_">demo</span>()<br><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">在es6之前没有块级作用域，并没有将下面的函数定义到其他函数中所以这两个函数是全局作用域的。</span><br><span class="hljs-comment">注意点：高级浏览器不会对花括号中的函数进行函数提升，只会在低级浏览器中按照正常方式解析,</span><br><span class="hljs-comment">（低级浏览器ie11以下的）正常情况是输出demo() 1，但在低级浏览器中会输出demo() 2</span><br><span class="hljs-comment">function demo()&#123;</span><br><span class="hljs-comment">    console.log(&#x27;demo() 1&#x27;);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">function demo()&#123;</span><br><span class="hljs-comment">    console.log(&#x27;demo() 2&#x27;);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">if(true)&#123;&#125;else&#123;&#125;</span><br><span class="hljs-comment">demo()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="预解析练习4"><a href="#预解析练习4" class="headerlink" title="预解析练习4"></a>预解析练习4</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br><span class="hljs-keyword">var</span> value = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">value</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fn value&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">注意点：变量与函数名称相同时，函数的优先级高于变量</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">function value()&#123;</span><br><span class="hljs-comment">    console.log(&#x27;fn value&#x27;);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">console.log(value)</span><br><span class="hljs-comment">var value;</span><br><span class="hljs-comment">value = 123;</span><br><span class="hljs-comment">console.log(value)</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vite项目初始化基建</title>
    <link href="/2024/02/20/vite%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E5%BB%BA/"/>
    <url>/2024/02/20/vite%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="配置eslint"><a href="#配置eslint" class="headerlink" title="配置eslint"></a>配置eslint</h2><h3 id="什么是eslint"><a href="#什么是eslint" class="headerlink" title="什么是eslint?"></a>什么是eslint?</h3><blockquote><p>ESLint 是一个 JavaScript 和 TypeScript 的静态代码分析工具，它用于识别代码中的问题并提供一致性和规范性。简单来说，它的作用是：</p><ol><li><strong>检测错误和潜在的问题：</strong> ESLint 可以帮助你找到代码中的错误、潜在的 bug 以及不规范的写法，从而提高代码的质量和稳定性。</li><li><strong>强制执行代码风格规范：</strong> 它可以根据预定义的规则或自定义的规则来强制执行一致的代码风格，以确保团队成员之间的代码风格一致，提高代码的可读性和可维护性。</li><li><strong>提供自定义规则和插件支持：</strong> ESLint 允许你根据项目的特定需求定义自定义规则，并且支持各种插件，可以满足不同项目的特定需求。</li></ol><p>总的来说，ESLint 可以帮助开发人员编写更加干净、可靠和符合规范的代码。</p></blockquote><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 方案<span class="hljs-number">1</span> <br>pnpm i -D eslint<br></code></pre></td></tr></table></figure><h3 id="规则方案"><a href="#规则方案" class="headerlink" title="规则方案"></a>规则方案</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 使用集成方案，内置好了所需规则<br>pnpm i -D @antfu/eslint-config <br><br># eslint默认方案，通过命令初始化eslint规则<br>npx eslint --init<br></code></pre></td></tr></table></figure><h4 id="eslint集成方案"><a href="#eslint集成方案" class="headerlink" title="eslint集成方案"></a>eslint集成方案</h4><blockquote><p>先安装方案一的@antfu&#x2F;eslint-config </p><p>在根目录新建 eslint.config.js即可</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> antfu <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@antfu/eslint-config&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">antfu</span>(&#123;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="eslint初始化默认方案（可选）"><a href="#eslint初始化默认方案（可选）" class="headerlink" title="eslint初始化默认方案（可选）"></a>eslint初始化默认方案（可选）</h4><h5 id="第一步-选择检测类型"><a href="#第一步-选择检测类型" class="headerlink" title="第一步 选择检测类型"></a>第一步 选择检测类型</h5><ul><li><p>仅检查语法</p></li><li><p>检查语法并查找问题</p></li><li><p>若要检查语法、寻找问题并胁迫执行程式码样式</p><p><strong>选择第二个，To check syntax and find problems</strong></p></li></ul><p><img src="https://tuchuang.junsen.online/i/2024/02/20/cjxore-2.png" alt="image-20240220075859922"></p><h5 id="第二步-选择项目是什么类型的模块"><a href="#第二步-选择项目是什么类型的模块" class="headerlink" title="第二步 选择项目是什么类型的模块"></a>第二步 选择项目是什么类型的模块</h5><p><strong>有以下三个选项，根据项目所需选择，这里使用的是js模块选择第一个即可</strong></p><ul><li>JavaScript模块（导入&#x2F;导出）</li><li>CommonJS（require&#x2F;exports）</li><li>没有这些</li></ul><p><img src="https://tuchuang.junsen.online/i/2024/02/20/dcgx0e-2.png" alt="image-20240220080700457"></p><h5 id="第三步-选择所使用的框架-根据你的项目选择即可"><a href="#第三步-选择所使用的框架-根据你的项目选择即可" class="headerlink" title="第三步 选择所使用的框架 根据你的项目选择即可"></a>第三步 选择所使用的框架 根据你的项目选择即可</h5><p><img src="https://tuchuang.junsen.online/i/2024/02/20/ddcik6-2.png" alt="image-20240220080847042"></p><h5 id="第四步-是否使用了ts-根据自己项目的选择"><a href="#第四步-是否使用了ts-根据自己项目的选择" class="headerlink" title="第四步 是否使用了ts,根据自己项目的选择"></a>第四步 是否使用了ts,根据自己项目的选择</h5><p><img src="https://tuchuang.junsen.online/i/2024/02/20/ddyrnf-2.png" alt="image-20240220080951098"></p><h5 id="第五步-选择运行环境，一般选浏览器，也就是第一个browser"><a href="#第五步-选择运行环境，一般选浏览器，也就是第一个browser" class="headerlink" title="第五步 选择运行环境，一般选浏览器，也就是第一个browser"></a>第五步 选择运行环境，一般选浏览器，也就是第一个browser</h5><p><img src="https://tuchuang.junsen.online/i/2024/02/20/defi6y-2.png" alt="image-20240220081029606"></p><h5 id="第六步-选择配置文件的类型，一般第一个即可"><a href="#第六步-选择配置文件的类型，一般第一个即可" class="headerlink" title="第六步 选择配置文件的类型，一般第一个即可"></a>第六步 选择配置文件的类型，一般第一个即可</h5><p><img src="https://tuchuang.junsen.online/i/2024/02/20/dezy1j-2.png" alt="image-20240220081125789"></p><h5 id="第七步-是否需要以下依赖，直接yes就行了，如果不用选no"><a href="#第七步-是否需要以下依赖，直接yes就行了，如果不用选no" class="headerlink" title="第七步 是否需要以下依赖，直接yes就行了，如果不用选no"></a>第七步 是否需要以下依赖，直接yes就行了，如果不用选no</h5><p><img src="https://tuchuang.junsen.online/i/2024/02/20/dfqdaq-2.png" alt="image-20240220081248294"></p><h5 id="第八步-选择安装依赖的方式，根据你项目所需的包管理选择"><a href="#第八步-选择安装依赖的方式，根据你项目所需的包管理选择" class="headerlink" title="第八步 选择安装依赖的方式，根据你项目所需的包管理选择"></a>第八步 选择安装依赖的方式，根据你项目所需的包管理选择</h5><p><img src="https://tuchuang.junsen.online/i/2024/02/20/dgn0by-2.png" alt="image-20240220081400408"></p><p><strong>执行完毕后的样子，根目录会多出 .eslintrc.cjs 的文件，在里面配置规则即可</strong></p><p><img src="https://tuchuang.junsen.online/i/2024/02/20/dhjk9n-2.png" alt="image-20240220081552312"></p><h3 id="vscode-settings-json"><a href="#vscode-settings-json" class="headerlink" title=".vscode&#x2F;settings.json"></a>.vscode&#x2F;settings.json</h3><blockquote><p>这个配置文件是用来配置编辑器（如 VSCode）的，主要针对 ESLint 和 Prettier 的设置。具体含义如下：</p><ul><li><code>&quot;eslint.experimental.useFlatConfig&quot;: true</code>: 启用 ESLint 的扁平配置支持。</li><li><code>&quot;prettier.enable&quot;: false</code>: 禁用默认的格式化程序，改用 ESLint 来格式化代码。</li><li><code>&quot;editor.formatOnSave&quot;: false</code>: 关闭在保存时自动格式化代码的功能。</li><li><code>&quot;editor.codeActionsOnSave&quot;</code>: 在保存时执行的代码操作，其中 <code>&quot;source.fixAll.eslint&quot;: &quot;explicit&quot;</code> 表示显式地自动修复 ESLint 报告的所有问题，<code>&quot;source.organizeImports&quot;: &quot;never&quot;</code> 表示不进行导入组织操作。</li><li><code>&quot;eslint.rules.customizations&quot;</code>: 定制 ESLint 规则，将一些样式规则的严重程度设置为 “off”，这样编辑器会静默地忽略这些规则，但仍会自动修复它们。</li><li><code>&quot;eslint.validate&quot;</code>: 启用 ESLint 对各种语言的验证，包括 JavaScript、TypeScript、Vue、HTML、Markdown 等。</li></ul></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">// 启用 ESLint 的扁平配置支持</span><br>  <span class="hljs-attr">&quot;eslint.experimental.useFlatConfig&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-comment">// 禁用默认的格式化程序，改用 ESLint</span><br>  <span class="hljs-attr">&quot;prettier.enable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;editor.formatOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-comment">// 自动修复</span><br>  <span class="hljs-attr">&quot;editor.codeActionsOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;source.fixAll.eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;explicit&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;source.organizeImports&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;never&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-comment">// 在编辑器中静默规避样式规则，但仍然自动修复它们</span><br>  <span class="hljs-attr">&quot;eslint.rules.customizations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;rule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;style/*&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;rule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;format/*&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;rule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*-indent&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;rule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*-spacing&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;rule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*-spaces&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;rule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*-order&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;rule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*-dangle&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;rule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*-newline&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;rule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*quotes&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;rule&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*semi&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-comment">// 对所有支持的语言启用 ESLint</span><br>  <span class="hljs-attr">&quot;eslint.validate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;javascript&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;javascriptreact&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;typescript&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;typescriptreact&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;vue&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;html&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;markdown&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;json&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;jsonc&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;yaml&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;toml&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><h2 id="配置husky"><a href="#配置husky" class="headerlink" title="配置husky"></a>配置husky</h2><h3 id="安装husky与lint-staged"><a href="#安装husky与lint-staged" class="headerlink" title="安装husky与lint-staged"></a>安装husky与lint-staged</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pnpm install -D husky lint-staged<br></code></pre></td></tr></table></figure><h3 id="初始化husky"><a href="#初始化husky" class="headerlink" title="初始化husky"></a>初始化husky</h3><blockquote><p>在package.json scripts里面新增下面语句初始化husky,也可以执行执行 npx husky-init，执行完毕后会在项目根目录自动新增.husky文件夹</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;prepare&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;husky install&quot;</span><br></code></pre></td></tr></table></figure><h3 id="指定husky给lint-staged执行"><a href="#指定husky给lint-staged执行" class="headerlink" title="指定husky给lint-staged执行"></a>指定husky给lint-staged执行</h3><blockquote><p>使用 lint-staged 的主要原因是它可以让 lint 工具只针对暂存区中的文件运行，而不是整个项目，这样可以提高 lint 的效率，只检查即将提交的代码，而不是整个项目的所有代码。这在大型项目中尤其有用，因为 lint-staged 可以帮助减少 lint 运行的时间，提高开发效率。</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npx husky <span class="hljs-keyword">add</span><span class="language-bash"> .husky/pre-commit <span class="hljs-string">&quot;npx lint-staged&quot;</span></span><br></code></pre></td></tr></table></figure><h2 id="配置commitlint"><a href="#配置commitlint" class="headerlink" title="配置commitlint"></a>配置commitlint</h2><blockquote><p>由于实际开发中会多人参与，对于我们的commit信息，也是有统一规范的，不能随便写,要让每个人都按照统一的标准来执行，我们可以利用<strong>commitlint</strong>来实现。根据<em><strong>Angular</strong></em>的提交规范会有以下几种</p></blockquote><table><thead><tr><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>build</td><td>编译相关的修改，例如发布版本、对项目构建或者依赖的改动</td></tr><tr><td>chore</td><td>其他修改, 比如改变构建流程、或者增加依赖库、工具等</td></tr><tr><td>ci</td><td>持续集成修改</td></tr><tr><td>docs</td><td>文档修改</td></tr><tr><td>feat</td><td>新特性、新功能</td></tr><tr><td>fix</td><td>修改bug</td></tr><tr><td>perf</td><td>优化相关，比如提升性能、体验</td></tr><tr><td>refactor</td><td>代码重构</td></tr><tr><td>revert</td><td>回滚到上一个版本</td></tr><tr><td>style</td><td>代码格式修改, 注意不是 css 修改</td></tr><tr><td>test</td><td>测试用例修改</td></tr></tbody></table><h3 id="安装-commitlint"><a href="#安装-commitlint" class="headerlink" title="安装  commitlint"></a>安装  commitlint</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pnpm add @commitlint/config-conventional @commitlint/cli -D<br></code></pre></td></tr></table></figure><h3 id="根目录-新建-commitlint-config-cjs"><a href="#根目录-新建-commitlint-config-cjs" class="headerlink" title="根目录 新建 commitlint.config.cjs"></a>根目录 新建 commitlint.config.cjs</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span>],<br>  <span class="hljs-comment">// 校验规则</span><br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-string">&#x27;type-enum&#x27;</span>: [<br>      <span class="hljs-number">2</span>,<br>      <span class="hljs-string">&#x27;always&#x27;</span>,<br>      [<br>        <span class="hljs-string">&#x27;feat&#x27;</span>,<br>        <span class="hljs-string">&#x27;fix&#x27;</span>,<br>        <span class="hljs-string">&#x27;docs&#x27;</span>,<br>        <span class="hljs-string">&#x27;style&#x27;</span>,<br>        <span class="hljs-string">&#x27;refactor&#x27;</span>,<br>        <span class="hljs-string">&#x27;perf&#x27;</span>,<br>        <span class="hljs-string">&#x27;test&#x27;</span>,<br>        <span class="hljs-string">&#x27;chore&#x27;</span>,<br>        <span class="hljs-string">&#x27;revert&#x27;</span>,<br>        <span class="hljs-string">&#x27;build&#x27;</span>,<br>      ],<br>    ],<br>    <span class="hljs-string">&#x27;type-case&#x27;</span>: [<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;type-empty&#x27;</span>: [<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;scope-empty&#x27;</span>: [<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;scope-case&#x27;</span>: [<span class="hljs-number">0</span>],<br>    <span class="hljs-string">&#x27;subject-full-stop&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;never&#x27;</span>],<br>    <span class="hljs-string">&#x27;subject-case&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;never&#x27;</span>],<br>    <span class="hljs-string">&#x27;header-max-length&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;always&#x27;</span>, <span class="hljs-number">72</span>],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在package-json中配置scripts命令"><a href="#在package-json中配置scripts命令" class="headerlink" title="在package.json中配置scripts命令"></a>在<code>package.json</code>中配置scripts命令</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 在scrips中添加下面的代码</span><br>&#123;<br><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;commitlint&quot;</span>: <span class="hljs-string">&quot;commitlint --config commitlint.config.cjs -e -V&quot;</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="给-husky新增commit-msg钩子指令"><a href="#给-husky新增commit-msg钩子指令" class="headerlink" title="给 husky新增commit-msg钩子指令"></a>给 husky新增commit-msg钩子指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx husky add .husky/commit-msg <br><br><span class="hljs-comment"># 在生成的commit-msg文件中添加下面的命令(路径在.husky/)</span><br><br><span class="hljs-comment">#!/usr/bin/env sh</span><br>. <span class="hljs-string">&quot;<span class="hljs-subst">$(dirname -- <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span>)</span>/_/husky.sh&quot;</span><br>pnpm commitlint<br></code></pre></td></tr></table></figure><blockquote><p>当我们git commit -m 时需要指定上面提到的前缀才能正常commit ，feat后面的冒号要英文的 :</p><p>git commit -m “feat: 新增commitlint规范Commit记录”</p></blockquote><h2 id="配置环境变量配置"><a href="#配置环境变量配置" class="headerlink" title="配置环境变量配置"></a>配置环境变量配置</h2><blockquote><ol><li><strong>安全性：</strong> 将敏感信息（如 API 密钥、数据库密码等）存储在环境变量中比直接硬编码在代码中更安全。这样做可以避免将这些敏感信息泄露到版本控制系统中，降低了信息泄露的风险。</li><li><strong>灵活性：</strong> 使用环境变量可以使你的应用程序在不同的环境中（例如开发、测试、生产）运行时具有不同的配置。你可以针对不同的环境设置不同的环境变量，而不需要修改代码。</li><li><strong>可维护性：</strong> 将配置信息放在环境变量中可以使代码更易于维护。如果需要更改配置，只需更改环境变量的值，而不需要修改代码并重新部署应用程序。</li><li><strong>可移植性：</strong> 使用环境变量可以使你的应用程序更具可移植性。你可以在不同的环境中轻松地部署应用程序，而无需担心配置信息的硬编码问题。</li></ol><p>综上所述，配置环境变量是一种良好的实践，可以提高应用程序的安全性、灵活性、可维护性和可移植性。</p></blockquote><h3 id="根目录新建开发、测试、生产环境配置文件"><a href="#根目录新建开发、测试、生产环境配置文件" class="headerlink" title="根目录新建开发、测试、生产环境配置文件"></a>根目录新建开发、测试、生产环境配置文件</h3><blockquote><p>下面命令执行不了可以直接根目录新建文件.env.development这种方式</p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">touch .env.development<br>touch .env.production<br>touch .env.test <br></code></pre></td></tr></table></figure><h3 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h3><h4 id="开发环境模板"><a href="#开发环境模板" class="headerlink" title="开发环境模板"></a>开发环境模板</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs env">NODE_ENV = &#x27;development&#x27;<br># 项目名称<br>VITE_APP_TITLE = &#x27;Vue 3 + Vite + TSX&#x27;<br># 请求根路径<br>VITE_APP_BASE_API = &#x27;/dev-api&#x27;<br># 请求地址<br>VITE_APP_BASE_URL = &#x27;http://localhost:3000&#x27;<br></code></pre></td></tr></table></figure><h4 id="生产环境模板"><a href="#生产环境模板" class="headerlink" title="生产环境模板"></a>生产环境模板</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">NODE_ENV</span> = <span class="hljs-string">&#x27;production&#x27;</span><br><span class="hljs-comment"># 项目名称</span><br><span class="hljs-attr">VITE_APP_TITLE</span> = <span class="hljs-string">&#x27;Vue 3 + Vite + TSX&#x27;</span><br><span class="hljs-comment"># 请求根路径</span><br><span class="hljs-attr">VITE_APP_BASE_API</span> = <span class="hljs-string">&#x27;/prod-api&#x27;</span><br><span class="hljs-comment"># 请求地址</span><br><span class="hljs-attr">VITE_APP_BASE_URL</span> = <span class="hljs-string">&#x27;http://junsen.online:3000&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="测试环境模板"><a href="#测试环境模板" class="headerlink" title="测试环境模板"></a>测试环境模板</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 变量必须以 VITE_ 为前缀才能暴露给外部读取</span><br><span class="hljs-attr">NODE_ENV</span> = <span class="hljs-string">&#x27;test&#x27;</span><br><span class="hljs-comment"># 项目名称</span><br><span class="hljs-attr">VITE_APP_TITLE</span> = <span class="hljs-string">&#x27;Vue 3 + Vite + TSX&#x27;</span><br><span class="hljs-comment"># 请求根路径</span><br><span class="hljs-attr">VITE_APP_BASE_API</span> = <span class="hljs-string">&#x27;/test-api&#x27;</span><br><span class="hljs-comment"># 请求地址</span><br><span class="hljs-attr">VITE_APP_BASE_URL</span> = <span class="hljs-string">&#x27;http://junsen.online:7001&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="启动时设置环境变量"><a href="#启动时设置环境变量" class="headerlink" title="启动时设置环境变量"></a>启动时设置环境变量</h4><blockquote><p>package.json scripts里面新增以下两条命令</p></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">&quot;<span class="hljs-keyword">build</span>:test<span class="hljs-string">&quot;: &quot;</span>vue-tsc &amp;&amp; vite <span class="hljs-keyword">build</span> --mode test<span class="hljs-string">&quot;,</span><br><span class="hljs-string">&quot;</span><span class="hljs-keyword">build</span>:pro<span class="hljs-string">&quot;: &quot;</span>vue-tsc &amp;&amp; vite <span class="hljs-keyword">build</span> --mode production<span class="hljs-string">&quot;,</span><br></code></pre></td></tr></table></figure><h4 id="给import-meta-env-添加变量提示"><a href="#给import-meta-env-添加变量提示" class="headerlink" title="给import.meta.env 添加变量提示"></a>给import.meta.env 添加变量提示</h4><blockquote><p>项目src目录下新增env.d.ts</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/// &lt;reference types=&quot;vite/client&quot; /&gt;</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ImportMetaEnv</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">VITE_APP_TITLE</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">// 更多环境变量...</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ImportMeta</span> &#123;<br>  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">env</span>: <span class="hljs-title class_">ImportMetaEnv</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://tuchuang.junsen.online/i/2024/02/21/24ycux-2.png" alt="image-20240221012925698"></p><h2 id="新增路径别名"><a href="#新增路径别名" class="headerlink" title="新增路径别名"></a>新增路径别名</h2><h3 id="在vite-config-ts中新增以下配置"><a href="#在vite-config-ts中新增以下配置" class="headerlink" title="在vite.config.ts中新增以下配置"></a>在vite.config.ts中新增以下配置</h3><blockquote><p>引入path冒红需要安装node头文件因为ts识别不出，执行pnpm add @types&#x2F;node</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;./src&#x27;</span>),<br>    &#125;,<br>  &#125;,<br></code></pre></td></tr></table></figure><p><img src="https://tuchuang.junsen.online/i/2024/02/21/2eo2iz-2.png" alt="image-20240221014556916"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>为什么不适用 prettier格式化？</p><ul><li>引用 antfu 的原话：如果你需要使用 ESLint，它也可以像 Prettier 一样格式化代码 - 而且更加可配置、Prettier + ESLint 仍然需要大量的配置 - 它并没有让你的生活变得更简单</li></ul><p>为什么要如此配置？</p><ul><li>可以规范化项目。从代码格式到校验、以及提交规范，开发环境区分，可以解决大部分因为规范引起代码混乱，不便于code review，</li><li>加上在ts的加持下，提供了静态类型检查的功能，可以在编译时捕获类型错误，避免在运行时出现类型相关的错误。这可以提高代码的可靠性和可维护性以及强大的代码提示和自动完成功能，可以帮助开发人员更快地编写代码、发现 API 和库的用法，并减少错误。</li></ul><p>还会有后续文章吗？</p><ul><li>会有的，后续的规划是复习node、webpack、vite等内容，从构建工具底层原理入手。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年前端开发年度总结</title>
    <link href="/2024/02/06/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <url>/2024/02/06/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>回顾这一年，我从大二兼职开发者到大三“全职开发”，见证了公司从成立初期到如今的发展。在2021年末，通过院长引荐，我参与了五邑大学某项目，与团队共同启动了长达一年的开发时限。公司于2022年后成立，我以兼职身份开始参与项目开发，在校期间，除了项目开发，我还投入双专业学习和各类竞赛，虽然部分技术提升有限，但微乎其微。</p><h2 id="2-技术成长"><a href="#2-技术成长" class="headerlink" title="2. 技术成长"></a>2. 技术成长</h2><h3 id="2-1-学习经历"><a href="#2-1-学习经历" class="headerlink" title="2.1 学习经历"></a>2.1 学习经历</h3><p>在2023年，我有幸参与了多个业务项目和百万用户的公益项目——诚信点评小程序。这一年，我不仅扩展了横向技能树，还转变为多领域开发者，涉及cocos游戏开发、自动化脚本开发、web3d开发等。在项目实际需求中，我深入学习了webgl、websocket、typescript、vue3、项目基建、git规范、cocos3d、UiAutomation、AiBote、vite、glsl、electorn、nestjs等技术，为公司业务的多样性提供了更广泛的支持。</p><h2 id="3-团队角色"><a href="#3-团队角色" class="headerlink" title="3. 团队角色"></a>3. 团队角色</h2><p>我在公司内部担任部分前端项目负责人，并担任新人培养导师。在工作期间，我主导了四个项目的基建与核心功能开发，取得了显著的团队成绩。</p><h2 id="4-发展计划"><a href="#4-发展计划" class="headerlink" title="4. 发展计划"></a>4. 发展计划</h2><p>展望未来，我期望在接下来的一年中能够主导更多基础建设项目，学习头部互联网企业所需的前沿技术，涉及更多底层原理，实现技术的深度和广度的双重提升。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>2023年不仅是对这一年的总结，更是对过去三年的总结与吐槽。公司提供了平台，但同时也限制了个人的提升。在项目中涉猎各个方向，虽然见识了更多领域，但也面临难以专精某一项的挑战。未来，我将继续努力，寻找平衡点，实现专业技能的全面提升。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>threejs轨道控制器辅助器</title>
    <link href="/2024/01/10/threejs%E8%BD%A8%E9%81%93%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BE%85%E5%8A%A9%E5%99%A8/"/>
    <url>/2024/01/10/threejs%E8%BD%A8%E9%81%93%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BE%85%E5%8A%A9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="threejs轨道控制器辅助器"><a href="#threejs轨道控制器辅助器" class="headerlink" title="threejs轨道控制器辅助器"></a>threejs轨道控制器辅助器</h1><blockquote><p>OrbitControlsHelper 由来，由于项目需要threejs默认的轨道控制器无法以模型为中心上下左右旋转，而是以修改相机视角达到视角旋转的效果当通过鼠标右键移动控制器后，相机的旋转会以世界中心旋转。</p><p>OrbitControlsHelper 可以把旋转中心从世界中心坐标改为模型中心旋转，可以参考下面的代码去理解。最后的是抽取成辅助类形式去调用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div ref=&quot;container&quot;&gt;<br>    &lt;!-- &lt;canvas ref=&quot;canvas&quot;&gt;&lt;/canvas&gt; --&gt;<br>    &lt;button @click=&quot;test(&#x27;0°&#x27;)&quot;&gt;回正&lt;/button&gt;<br>    &lt;button @click=&quot;test(&#x27;R45°&#x27;)&quot;&gt;R45°&lt;/button&gt;<br>    &lt;button @click=&quot;test(&#x27;L45°&#x27;)&quot;&gt;L45°&lt;/button&gt;<br>    &lt;button @click=&quot;test(&#x27;R90°&#x27;)&quot;&gt;R90°&lt;/button&gt;<br>    &lt;button @click=&quot;test(&#x27;L90°&#x27;)&quot;&gt;L90°&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;<br>import * as THREE from &#x27;three&#x27;;<br>import &#123; OrbitControls &#125; from &#x27;three/addons/controls/OrbitControls.js&#x27;;<br><br>const container = ref();<br>let camera: any;<br>let controls: any;<br>let cube: any;<br>const init = () =&gt; &#123;<br>  // 初始化场景<br>  const scene = new THREE.Scene();<br>  camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);<br>  const renderer = new THREE.WebGLRenderer();<br>  camera.position.z = 5;<br>  renderer.setSize(window.innerWidth, window.innerHeight);<br>  container.value.appendChild(renderer.domElement);<br><br>  controls = new OrbitControls(camera, renderer.domElement);<br>  controls.enableRotate = false;<br>  controls.enableZoom = false;<br>  // 如果OrbitControls改变了相机参数，重新调用渲染器渲染三维场景<br>  controls.addEventListener(&#x27;change&#x27;, function () &#123;<br>    renderer.render(scene, camera); // 执行渲染操作<br>  &#125;); // 监听鼠标、键盘事件<br><br>  //   const gridHelper = new THREE.GridHelper(300, 25, 0x004444, 0x004444);<br><br>  //   scene.add(gridHelper);<br>  const geometry = new THREE.BoxGeometry(1, 1, 1);<br>  const material = new THREE.MeshBasicMaterial(&#123; color: 0x00ff00 &#125;);<br>  cube = new THREE.Mesh(geometry, material);<br>  scene.add(cube);<br><br>  // 初始化控制参数<br>  const state = &#123;<br>    isLongPressing: false,<br>    longPressThreshold: 100, // 长按阈值，单位为毫秒<br>    pressStartTime: 0,<br>    previousMousePosition: &#123;<br>      x: 0,<br>      y: 0,<br>    &#125;,<br>    longPressTimer: undefined, // 用于存储定时器的ID<br>  &#125;;<br><br>  // 鼠标按下事件<br>  const handleMouseDown = (event: MouseEvent) =&gt; &#123;<br>    if (event.button === 0) &#123;<br>      // 检查左键<br>      state.pressStartTime = Date.now();<br>      state.isLongPressing = false;<br>      state.previousMousePosition.x = event.clientX;<br>      state.previousMousePosition.y = event.clientY;<br>      state.longPressTimer = setTimeout(checkLongPress, state.longPressThreshold) as unknown as any;<br>    &#125;<br>  &#125;;<br><br>  // 鼠标松开事件<br>  const handleMouseUp = () =&gt; &#123;<br>    state.isLongPressing = false;<br>    clearTimeout(state.longPressTimer);<br>  &#125;;<br>  // 检查长按<br>  function checkLongPress() &#123;<br>    const currentTime = Date.now();<br>    if (currentTime - state.pressStartTime &gt;= state.longPressThreshold) &#123;<br>      // 左键长按的处理代码<br>      state.isLongPressing = true;<br>      console.log(&#x27;左键长按&#x27;);<br>    &#125;<br>  &#125;<br>  // 鼠标移动事件<br>  const handleMouseMove = (event: MouseEvent) =&gt; &#123;<br>    if (state.isLongPressing) &#123;<br>      // 在长按状态下的鼠标移动处理代码<br>      const deltaMove = &#123;<br>        x: event.pageX - state.previousMousePosition.x,<br>        y: event.pageY - state.previousMousePosition.y,<br>      &#125;;<br>      // 获取关联的 DOM 元素<br>      const element = renderer.domElement;<br>      cube.rotation.x += (2 * Math.PI * deltaMove.y) / element.clientHeight;<br>      cube.rotation.y += (2 * Math.PI * deltaMove.x) / element.clientWidth;<br>      // 更新鼠标位置<br>      state.previousMousePosition = &#123;<br>        x: event.pageX,<br>        y: event.pageY,<br>      &#125;;<br>    &#125;<br>  &#125;;<br>  // 滚轮事件<br>  const handleWheel = (event: WheelEvent) =&gt; &#123;<br>    // 根据滚轮滚动的差值进行缩放<br>    const scaleFactor = event.deltaY &gt; 0 ? 0.9 : 1.1;<br>    cube.scale.multiplyScalar(scaleFactor);<br>  &#125;;<br><br>  // 渲染循环<br>  const animate = () =&gt; &#123;<br>    requestAnimationFrame(animate);<br>    renderer.render(scene, camera);<br>  &#125;;<br><br>  // 初始化相机位置<br>  camera.position.z = 5;<br><br>  // 启动渲染循环<br>  animate();<br><br>  document.addEventListener(&#x27;mousedown&#x27;, handleMouseDown);<br>  document.addEventListener(&#x27;mouseup&#x27;, handleMouseUp);<br>  document.addEventListener(&#x27;mousemove&#x27;, handleMouseMove);<br>  document.addEventListener(&#x27;wheel&#x27;, handleWheel);<br>&#125;;<br><br>const test = (degToRad: string) =&gt; &#123;<br>  console.log(controls);<br><br>  switch (degToRad) &#123;<br>    // 0°旋转的情况<br>    case &#x27;0°&#x27;:<br>      // 设置左右两个相机的旋转<br>      cube.rotation.set(0, THREE.MathUtils.degToRad(0), 0);<br>      break;<br><br>    // +45°旋转的情况<br>    case &#x27;R45°&#x27;:<br>      cube.rotation.set(0, THREE.MathUtils.degToRad(45), 0);<br>      break;<br><br>    // -45°旋转的情况<br>    case &#x27;L45°&#x27;:<br>      cube.rotation.set(0, -THREE.MathUtils.degToRad(45), 0);<br>      break;<br><br>    // +90°旋转的情况<br>    case &#x27;R90°&#x27;:<br>      cube.rotation.set(0, THREE.MathUtils.degToRad(90), 0);<br>      break;<br><br>    // -90°旋转的情况<br>    case &#x27;L90°&#x27;:<br>      cube.rotation.set(0, -THREE.MathUtils.degToRad(90), 0);<br>      break;<br>  &#125;<br>  // 设置轨道控制器的目标点（target）为初始位置<br>  controls.target.set(0, 0, 0);<br><br>  // 设置相机的位置为默认位置<br>  camera.position.set(0, 0, 5); // 你可能需要根据实际情况调整 Z 轴的值<br><br>  // 使相机重新对准目标点<br>  controls.update();<br><br>  console.log(controls);<br>&#125;;<br><br>// 注册事件监听器<br>onMounted(() =&gt; &#123;<br>  init();<br>&#125;);<br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure><h2 id="抽取后的代码"><a href="#抽取后的代码" class="headerlink" title="抽取后的代码"></a>抽取后的代码</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// eslint-disable-next-line filename-rules/match</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrbitControlsHelper</span> &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-built_in">any</span> = &#123;<br>    <span class="hljs-comment">// 是否正在长按的状态，初始值为 false</span><br>    <span class="hljs-attr">isLongPressing</span>: <span class="hljs-literal">false</span>,<br><br>    <span class="hljs-comment">// 长按的阈值，单位为毫秒，如果按下的时间超过这个阈值，则认为是长按</span><br>    <span class="hljs-attr">longPressThreshold</span>: <span class="hljs-number">100</span>,<br><br>    <span class="hljs-comment">// 记录按下鼠标的时间，用于计算是否长按</span><br>    <span class="hljs-attr">pressStartTime</span>: <span class="hljs-number">0</span>,<br><br>    <span class="hljs-comment">// 记录上一次鼠标的位置，用于计算鼠标移动的距离</span><br>    <span class="hljs-attr">previousMousePosition</span>: &#123;<br>      <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,<br>    &#125;,<br><br>    <span class="hljs-comment">// 用于存储定时器的 ID，定时器用于检查是否长按</span><br>    <span class="hljs-attr">longPressTimer</span>: <span class="hljs-literal">undefined</span>,<br><br>    <span class="hljs-comment">// 存储双指触摸开始时的距离，用于计算缩放比例</span><br>    <span class="hljs-attr">touchStartDistance</span>: <span class="hljs-number">0</span>,<br><br>    <span class="hljs-comment">// 存储触摸缩放因子，用于在触摸移动时计算新的缩放比例</span><br>    <span class="hljs-title class_">ScaleFactor</span>: [-<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    <span class="hljs-title class_">Rotation</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>  &#125;;<br><br>  <span class="hljs-comment">// 存储 THREE.js 模型的数组，每个模型都是一个 THREE.Group 对象</span><br>  <span class="hljs-attr">models</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">Group</span>&lt;<span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">Object3DEventMap</span>&gt;[] = [];<br><br>  <span class="hljs-comment">// 存储画布</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">element</span>: <span class="hljs-title class_">HTMLCanvasElement</span>;<br><br>  <span class="hljs-comment">// 构造函数，接收一个 HTMLCanvasElement 参数，为其添加事件监听器</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> el: HTMLCanvasElement</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span> = el!;<br>    <span class="hljs-comment">// 添加鼠标按下事件监听器，用于处理鼠标按下事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousedown&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleMouseDown</span>);<br><br>    <span class="hljs-comment">// 添加鼠标抬起事件监听器，用于处理鼠标抬起事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseup&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleMouseUp</span>);<br><br>    <span class="hljs-comment">// 添加鼠标移动事件监听器，用于处理鼠标移动事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleMouseMove</span>);<br><br>    <span class="hljs-comment">// 添加滚轮滚动事件监听器，用于处理滚轮滚动事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;wheel&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleWheel</span>);<br><br>    <span class="hljs-comment">// 添加触摸开始事件监听器，用于处理触摸开始事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleTouchStart</span>, &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;);<br><br>    <span class="hljs-comment">// 添加触摸结束事件监听器，用于处理触摸结束事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchend&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleTouchEnd</span>);<br><br>    <span class="hljs-comment">// 添加触摸移动事件监听器，用于处理触摸移动事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleTouchMove</span>, &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">false</span> &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// 检查是否长按的方法</span><br>  checkLongPress = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 获取当前时间</span><br>    <span class="hljs-keyword">const</span> currentTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果从按下鼠标到现在的时间超过了长按阈值，则认为是长按</span><br>    <span class="hljs-keyword">if</span> (currentTime - <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">pressStartTime</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">longPressThreshold</span>) &#123;<br>      <span class="hljs-comment">// 设置长按状态为 true</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isLongPressing</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// 处理鼠标抬起的方法</span><br>  handleMouseUp = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 鼠标抬起时，设置长按状态为 false，并清除长按检查的定时器</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isLongPressing</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">clearTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">longPressTimer</span>);<br>  &#125;;<br><br>  <span class="hljs-comment">// 处理鼠标按下的方法</span><br>  handleMouseDown = <span class="hljs-function">(<span class="hljs-params">event: MouseEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只处理左键按下事件</span><br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">button</span> === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 记录按下鼠标的时间，设置长按状态为 false，记录鼠标的位置，并设置一个定时器来检查是否长按</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">pressStartTime</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isLongPressing</span> = <span class="hljs-literal">false</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">previousMousePosition</span>.<span class="hljs-property">x</span> = event.<span class="hljs-property">clientX</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">previousMousePosition</span>.<span class="hljs-property">y</span> = event.<span class="hljs-property">clientY</span>;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">longPressTimer</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">checkLongPress</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">longPressThreshold</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// 处理鼠标移动的方法</span><br>  handleMouseMove = <span class="hljs-function">(<span class="hljs-params">event: MouseEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只在长按状态下处理鼠标移动事件</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isLongPressing</span>) &#123;<br>      <span class="hljs-comment">// 计算鼠标移动的距离</span><br>      <span class="hljs-keyword">const</span> deltaMove = &#123;<br>        <span class="hljs-attr">x</span>: event.<span class="hljs-property">pageX</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">previousMousePosition</span>.<span class="hljs-property">x</span>,<br>        <span class="hljs-attr">y</span>: event.<span class="hljs-property">pageY</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">previousMousePosition</span>.<span class="hljs-property">y</span>,<br>      &#125;;<br><br>      <span class="hljs-comment">// 遍历所有模型</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">models</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">model</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (model) &#123;<br>          <span class="hljs-comment">// 计算新的旋转角度公式：新的角度 = 旧的角度 + (2π * 移动的距离 / 元素的高度或宽度)。</span><br>          <span class="hljs-comment">// 当鼠标在元素上从一端移动到另一端时，模型应该旋转 360 度（即 2π 弧度）。</span><br>          <span class="hljs-keyword">const</span> newRotationX = model.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> + (<span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * deltaMove.<span class="hljs-property">y</span>) / <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">clientHeight</span>;<br>          <span class="hljs-keyword">const</span> newRotationY = model.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> + (<span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * deltaMove.<span class="hljs-property">x</span>) / <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-property">clientWidth</span>;<br><br>          <span class="hljs-comment">// 将角度转换为度数公式为：度数 = 弧度 * (180 / π)。</span><br>          <span class="hljs-keyword">const</span> newRotationXInDegrees = newRotationX * (<span class="hljs-number">180</span> / <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);<br>          <span class="hljs-keyword">const</span> newRotationYInDegrees = newRotationY * (<span class="hljs-number">180</span> / <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>);<br><br>          <span class="hljs-comment">// 检查新的旋转角度是否在 -90 度到 90 度的范围内，如果是，则更新模型的旋转角度</span><br>          <span class="hljs-keyword">if</span> (newRotationXInDegrees &gt;= -<span class="hljs-number">90</span> &amp;&amp; newRotationXInDegrees &lt;= <span class="hljs-number">90</span>) &#123;<br>            model.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> = newRotationX;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (newRotationYInDegrees &gt;= -<span class="hljs-number">90</span> &amp;&amp; newRotationYInDegrees &lt;= <span class="hljs-number">90</span>) &#123;<br>            model.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> = newRotationY;<br>          &#125;<br><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">Rotation</span> = [...model.<span class="hljs-property">rotation</span>];<br>        &#125;<br>      &#125;);<br><br>      <span class="hljs-comment">// 更新鼠标的位置，以便下次计算移动距离</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">previousMousePosition</span> = &#123;<br>        <span class="hljs-attr">x</span>: event.<span class="hljs-property">pageX</span>,<br>        <span class="hljs-attr">y</span>: event.<span class="hljs-property">pageY</span>,<br>      &#125;;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// 处理滚轮滚动的方法</span><br>  handleWheel = <span class="hljs-function">(<span class="hljs-params">event: WheelEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 根据滚轮滚动的差值进行缩放，滚轮向下滚动时缩小，向上滚动时放大</span><br>    <span class="hljs-keyword">const</span> scaleFactor = event.<span class="hljs-property">deltaY</span> &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0.9</span> : <span class="hljs-number">1.1</span>;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">models</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">model</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (model) &#123;<br>        <span class="hljs-comment">// 计算新的缩放值，新的缩放值 = 旧的缩放值 * 缩放因子</span><br>        <span class="hljs-keyword">const</span> newScale = model.<span class="hljs-property">scale</span>.<span class="hljs-title function_">clone</span>().<span class="hljs-title function_">multiplyScalar</span>(scaleFactor);<br><br>        <span class="hljs-comment">// 设置缩放范围，例如，假设缩放范围在 -40 到 40 之间</span><br>        <span class="hljs-keyword">const</span> minScale = -<span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">const</span> maxScale = <span class="hljs-number">60</span>;<br>        <span class="hljs-keyword">if</span> (newScale.<span class="hljs-property">x</span> &lt;= -<span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-comment">// 限制缩放值在范围内</span><br>          newScale.<span class="hljs-title function_">clampScalar</span>(minScale, maxScale);<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">ScaleFactor</span> = [...newScale];<br>          <span class="hljs-comment">// 应用新的缩放值</span><br>          model.<span class="hljs-property">scale</span>.<span class="hljs-title function_">copy</span>(newScale);<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-comment">// 处理触摸结束的方法</span><br>  handleTouchEnd = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 触摸结束时，调用 handleMouseUp 方法处理</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleMouseUp</span>();<br>  &#125;;<br><br>  <span class="hljs-comment">// 将触摸事件转换为鼠标事件的方法</span><br>  convertTouchEvent = (<span class="hljs-attr">event</span>: <span class="hljs-title class_">TouchEvent</span>): <span class="hljs-function"><span class="hljs-params">MouseEvent</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 获取第一个触摸点</span><br>    <span class="hljs-keyword">const</span> touch = event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>] || event.<span class="hljs-property">changedTouches</span>[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-comment">// 创建一个新的鼠标事件，并设置其 clientX 和 clientY 为触摸点的位置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MouseEvent</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, &#123;<br>      <span class="hljs-attr">clientX</span>: touch.<span class="hljs-property">clientX</span>,<br>      <span class="hljs-attr">clientY</span>: touch.<span class="hljs-property">clientY</span>,<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-comment">// 处理触摸开始的方法</span><br>  handleTouchStart = <span class="hljs-function">(<span class="hljs-params">event: TouchEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 阻止默认行为</span><br>    event.<span class="hljs-title function_">preventDefault</span>();<br><br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">touches</span>.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">// 单指触摸时，调用 handleMouseDown 方法处理，并将触摸事件转换为鼠标事件</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleMouseDown</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">convertTouchEvent</span>(event));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.<span class="hljs-property">touches</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-comment">// 双指触摸时，计算两个触摸点之间的距离</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">touchStartDistance</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getTouchesDistance</span>(event.<span class="hljs-property">touches</span>);<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// 处理触摸移动的方法</span><br>  handleTouchMove = <span class="hljs-function">(<span class="hljs-params">event: TouchEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 阻止默认行为</span><br>    event.<span class="hljs-title function_">preventDefault</span>();<br><br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">touches</span>.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">// 单指移动时，调用 handleMouseMove 方法处理，并将触摸事件转换为鼠标事件</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleMouseMove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">convertTouchEvent</span>(event));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.<span class="hljs-property">touches</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-comment">// 双指移动时，计算两个触摸点之间的新距离</span><br>      <span class="hljs-keyword">const</span> newDistance = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getTouchesDistance</span>(event.<span class="hljs-property">touches</span>);<br><br>      <span class="hljs-comment">// 设置一个阈值，例如10个像素，以确定是否进行了显著的缩放操作</span><br>      <span class="hljs-keyword">const</span> threshold = <span class="hljs-number">10</span>;<br>      <span class="hljs-keyword">const</span> distanceChange = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(newDistance - <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">touchStartDistance</span>);<br><br>      <span class="hljs-keyword">if</span> (distanceChange &gt; threshold) &#123;<br>        <span class="hljs-comment">// 只有当距离变化超过阈值时，才进行缩放。如果新距离大于起始距离，放大模型，否则缩小模型</span><br>        <span class="hljs-keyword">const</span> scaleFactor = newDistance &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">touchStartDistance</span> ? <span class="hljs-number">1.1</span> : <span class="hljs-number">0.9</span>;<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">models</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">model</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (model) &#123;<br>            <span class="hljs-comment">// 计算新的缩放值，新的缩放值 = 旧的缩放值 * 缩放因子</span><br>            <span class="hljs-keyword">const</span> newScale = model.<span class="hljs-property">scale</span>.<span class="hljs-title function_">clone</span>().<span class="hljs-title function_">multiplyScalar</span>(scaleFactor);<br>            <span class="hljs-keyword">const</span> minScale = -<span class="hljs-number">60</span>;<br>            <span class="hljs-keyword">const</span> maxScale = <span class="hljs-number">60</span>;<br><br>            <span class="hljs-keyword">if</span> (newScale.<span class="hljs-property">x</span> &lt;= -<span class="hljs-number">2</span>) &#123;<br>              <span class="hljs-comment">// 限制缩放值在范围内</span><br>              newScale.<span class="hljs-title function_">clampScalar</span>(minScale, maxScale);<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">ScaleFactor</span> = [...newScale];<br>              <span class="hljs-comment">// 应用新的缩放值</span><br>              model.<span class="hljs-property">scale</span>.<span class="hljs-title function_">copy</span>(newScale);<br>            &#125;<br>          &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 更新起始距离，以便下次计算距离变化</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">touchStartDistance</span> = newDistance;<br>      &#125;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// 计算两个触摸点之间的距离的方法</span><br>  getTouchesDistance = <span class="hljs-function">(<span class="hljs-params">touches: TouchList</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 计算两个触摸点在 x 轴和 y 轴上的差值</span><br>    <span class="hljs-keyword">const</span> dx = touches[<span class="hljs-number">0</span>].<span class="hljs-property">pageX</span> - touches[<span class="hljs-number">1</span>].<span class="hljs-property">clientX</span>;<br>    <span class="hljs-keyword">const</span> dy = touches[<span class="hljs-number">0</span>].<span class="hljs-property">pageY</span> - touches[<span class="hljs-number">1</span>].<span class="hljs-property">clientY</span>;<br><br>    <span class="hljs-comment">// 使用勾股定理计算两个触摸点之间的距离</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(dx * dx + dy * dy);<br>  &#125;;<br><br>  <span class="hljs-comment">// 加载模型的方法</span><br>  loadModels = <span class="hljs-function">(<span class="hljs-params">models: THREE.Group&lt;THREE.Object3DEventMap&gt;[]</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 将传入的模型赋值给 this.models</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">models</span> = models;<br>  &#125;;<br><br>  <span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;mousedown&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleMouseDown</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;mouseup&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleMouseUp</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleMouseMove</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;wheel&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleWheel</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleTouchStart</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;touchend&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleTouchEnd</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleTouchMove</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 计算缩放比</span><br>  <span class="hljs-title function_">calculateScalingRatio</span>(<span class="hljs-params">aspectRatio</span>) &#123;<br>    <span class="hljs-comment">// 初始化缩放比</span><br>    <span class="hljs-comment">// 计算新的缩放比例</span><br>    <span class="hljs-comment">// const aspectRatio = sceneWidth / sceneHeight;</span><br>    <span class="hljs-keyword">let</span> scaleRatio = aspectRatio / <span class="hljs-number">0.5</span>; <span class="hljs-comment">// 计算缩放比例</span><br>    scaleRatio = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(scaleRatio, <span class="hljs-number">1</span>); <span class="hljs-comment">// 限制缩放比例的最大值为1，确保模型不会变得过大</span><br>    <span class="hljs-keyword">const</span> scale = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(-<span class="hljs-number">8</span> * scaleRatio); <span class="hljs-comment">// 取绝对值，确保缩放比例始终为正值</span><br>    <span class="hljs-comment">// 更新模型的缩放比例</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">ScaleFactor</span> = [-scale, scale, scale];<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">orbitControlsHelper</span>: <span class="hljs-built_in">any</span>;<br><br># 创建轨道控制器辅助器<br>orbitControlsHelper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrbitControlsHelper</span>(renderer.<span class="hljs-property">value</span>.<span class="hljs-property">domElement</span>);<br>orbitControlsHelper.<span class="hljs-title function_">calculateScalingRatio</span>(cameraLeft.<span class="hljs-property">aspect</span>);<br># 禁用 轨道控制器缩放和平移旋转事件<br>controls.<span class="hljs-property">enableRotate</span> = <span class="hljs-literal">false</span>;<br>controls.<span class="hljs-property">enableZoom</span> = <span class="hljs-literal">false</span>;<br><br># 订阅鼠标按键事件<br>renderer.<span class="hljs-property">value</span>.<span class="hljs-property">domElement</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousedown&#x27;</span>, orbitControlsHelper.<span class="hljs-property">handleMouseDown</span>);<br>renderer.<span class="hljs-property">value</span>.<span class="hljs-property">domElement</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseup&#x27;</span>, orbitControlsHelper.<span class="hljs-property">handleMouseUp</span>);<br>renderer.<span class="hljs-property">value</span>.<span class="hljs-property">domElement</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, orbitControlsHelper.<span class="hljs-property">handleMouseMove</span>);<br>renderer.<span class="hljs-property">value</span>.<span class="hljs-property">domElement</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;wheel&#x27;</span>, orbitControlsHelper.<span class="hljs-property">handleWheel</span>);<br><br>#在执行动画渲染的函数加载需要修改的模型<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 执行动画渲染的函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">animate</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">requestAnimationFrame</span>(animate);<br>  # 加载模型<br>  orbitControlsHelper.<span class="hljs-title function_">loadModels</span>([<span class="hljs-title class_">FaceModelOne</span>, <span class="hljs-title class_">FaceModelTwo</span>, <span class="hljs-title class_">HistoryFaceModel</span>]);<br>  <span class="hljs-comment">// 渲染左眼场景</span><br>  renderer.<span class="hljs-property">value</span>.<span class="hljs-title function_">setViewport</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width.<span class="hljs-property">value</span>, height.<span class="hljs-property">value</span>);<br>  renderer.<span class="hljs-property">value</span>.<span class="hljs-title function_">setScissor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width.<span class="hljs-property">value</span>, height.<span class="hljs-property">value</span>);<br>  renderer.<span class="hljs-property">value</span>.<span class="hljs-title function_">setScissorTest</span>(<span class="hljs-literal">true</span>);<br>  renderer.<span class="hljs-property">value</span>.<span class="hljs-title function_">render</span>(sceneLeft, cameraLeft.<span class="hljs-property">value</span>);<br>  renderer.<span class="hljs-property">value</span>.<span class="hljs-title function_">setPixelRatio</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>);<br><br>  <span class="hljs-comment">// 渲染右眼场景</span><br>  renderer.<span class="hljs-property">value</span>.<span class="hljs-title function_">setViewport</span>(width.<span class="hljs-property">value</span>, <span class="hljs-number">0</span>, width.<span class="hljs-property">value</span>, height.<span class="hljs-property">value</span>);<br>  renderer.<span class="hljs-property">value</span>.<span class="hljs-title function_">setScissor</span>(width.<span class="hljs-property">value</span>, <span class="hljs-number">0</span>, width.<span class="hljs-property">value</span>, height.<span class="hljs-property">value</span>);<br>  renderer.<span class="hljs-property">value</span>.<span class="hljs-title function_">setScissorTest</span>(<span class="hljs-literal">true</span>);<br>  renderer.<span class="hljs-property">value</span>.<span class="hljs-title function_">render</span>(sceneRight, cameraRight.<span class="hljs-property">value</span>);<br>  renderer.<span class="hljs-property">value</span>.<span class="hljs-title function_">setPixelRatio</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>threejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web3d</tag>
      
      <tag>threejs</tag>
      
      <tag>webgl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3-ts-vite集成electron记录</title>
    <link href="/2023/11/26/vue3-ts-vite%E9%9B%86%E6%88%90electron%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/11/26/vue3-ts-vite%E9%9B%86%E6%88%90electron%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="vue3-ts-vite集成electron记录"><a href="#vue3-ts-vite集成electron记录" class="headerlink" title="vue3-ts-vite集成electron记录"></a>vue3-ts-vite集成electron记录</h1><h2 id="安装electron、electron-builder"><a href="#安装electron、electron-builder" class="headerlink" title="安装electron、electron-builder"></a>安装electron、electron-builder</h2><blockquote><p>npm install –save-dev electron electron-builder</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><p>项目目录结构</p><p>│  .cz-config.js<br>│  .env<br>│  .env.development<br>│  .env.production<br>│  .eslintrc.cjs<br>│  .gitignore<br>│  .npmrc<br>│  .prettierrc.json<br>│  catalogTree.txt<br>│  commitlint.config.cjs<br>│  env.d.ts<br>│  index.html<br>│  package.json<br>│  pnpm-lock.yaml<br>│  README.md<br>│  tsconfig.app.json<br>│  tsconfig.json<br>│  tsconfig.node.json<br>│  uno.config.ts<br>│  vite.config.ts<br>│<br>├─.husky<br>│      commit-msg<br>│      pre-commit<br>│<br>├─.vscode<br>│      extensions.json<br>│<br>├─electron<br>│  │  background.ts<br>│  │<br>│  ├─plugins<br>│  │      vite-electron-build.ts<br>│  │      vite-electron-dev.ts<br>│  │<br>│  ├─preload<br>│  │      index.ts<br>│  │<br>│  └─utils<br>│          build.ts<br>│          handle-files.ts<br>│<br>├─public<br>│      favicon.ico<br>│<br>└─src<br>    │  App.vue<br>    │  env.d.ts<br>    │  global.d.ts<br>    │  main.ts<br>    │<br>    ├─assets<br>    │      base.css<br>    │      logo.svg<br>    │      main.css<br>    │<br>    ├─request<br>    │      index.ts<br>    │<br>    ├─router<br>    │      index.ts<br>    │<br>    ├─stores<br>    │      counter.ts<br>    │<br>    ├─utils<br>    │      indexed-db.ts<br>    │<br>    └─views<br>            ThreeDemo.vue</p></blockquote><h3 id="根目录新建electron文件夹"><a href="#根目录新建electron文件夹" class="headerlink" title="根目录新建electron文件夹"></a>根目录新建electron文件夹</h3><blockquote><p>安装我的项目结构在根目录新建electron文件夹以及文件夹内的所有文件夹与文件</p></blockquote><ul><li><p>background.ts 等同于electron文档中介绍的 main.js，因为项目已经存在main.ts，命名冲突</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> electron 主进程文件，因为项目已经有同名的main.ts了，所以使用background.ts</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><span class="hljs-keyword">import</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;electron&#x27;</span><br><br><span class="hljs-comment">// 禁用electron缓存</span><br>app.<span class="hljs-property">commandLine</span>.<span class="hljs-title function_">appendSwitch</span>(<span class="hljs-string">&#x27;disable-gpu-cache&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWindow</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> win = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrowserWindow</span>(&#123;<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">800</span>,<br>        <span class="hljs-attr">height</span>: <span class="hljs-number">600</span>,<br>        <span class="hljs-attr">autoHideMenuBar</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">webPreferences</span>: &#123;<br>            <span class="hljs-attr">preload</span>: process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>]<br>                ? path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;../preload/index.ts&#x27;</span>)<br>                : path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;preload/index.js&#x27;</span>),<br>            <span class="hljs-attr">nodeIntegration</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 禁用 Node.js 整合</span><br>            <span class="hljs-attr">contextIsolation</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用上下文隔离</span><br>            <span class="hljs-attr">sandbox</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用沙盒模式</span><br>            <span class="hljs-attr">webSecurity</span>: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;)<br><br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>]) &#123;<br>        win.<span class="hljs-property">webContents</span>.<span class="hljs-title function_">openDevTools</span>()<br>        win.<span class="hljs-title function_">loadURL</span>(process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        win.<span class="hljs-title function_">loadFile</span>(<span class="hljs-string">&#x27;index.html&#x27;</span>)<br>    &#125;<br>&#125;<br><br>app.<span class="hljs-title function_">whenReady</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">createWindow</span>()<br>    app.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">BrowserWindow</span>.<span class="hljs-title function_">getAllWindows</span>().<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-title function_">createWindow</span>()<br>        &#125;<br>    &#125;)<br>&#125;)<br><br>app.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;window-all-closed&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">platform</span> !== <span class="hljs-string">&#x27;darwin&#x27;</span>) &#123;<br>        app.<span class="hljs-title function_">quit</span>()<br>    &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure></li><li><p>utils里面的build.ts、handle-files.ts，分别处理electron文件的热更新、与项目的dist打包文件同步</p><ul><li>utils&#x2F;build.ts</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">buildBackground</span> = (<span class="hljs-params">entryPoints: <span class="hljs-built_in">string</span>, outfile: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>    <span class="hljs-comment">// entryPoints: [&#x27;electron/background.ts&#x27;],</span><br>    <span class="hljs-comment">// outfile: &#x27;electron/dist/background.js&#x27;,</span><br><br>    <span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/no-var-requires</span><br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esbuild&#x27;</span>).<span class="hljs-title function_">buildSync</span>(&#123;<br>        <span class="hljs-attr">entryPoints</span>: [entryPoints],<br>        <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;es2020&#x27;</span>,<br>        outfile,<br>        <span class="hljs-attr">platform</span>: <span class="hljs-string">&#x27;node&#x27;</span>,<br>        <span class="hljs-attr">external</span>: [<span class="hljs-string">&#x27;electron&#x27;</span>]<br>    &#125;)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><ul><li><p>electron&#x2F;utils&#x2F;handle-files.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><br><span class="hljs-comment">// 使用 fs 模块进行清空目标目录</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">emptyDirectorySync</span>(<span class="hljs-params">directory: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(directory)) &#123;<br>        <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(directory)<br><br>        files.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(directory, file)<br><br>            <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">lstatSync</span>(filePath).<span class="hljs-title function_">isDirectory</span>()) &#123;<br>                <span class="hljs-title function_">emptyDirectorySync</span>(filePath)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                fs.<span class="hljs-title function_">unlinkSync</span>(filePath)<br>            &#125;<br>        &#125;)<br><br>        fs.<span class="hljs-title function_">rmdirSync</span>(directory)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 fs 模块进行复制</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">copyFolderSync</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, target: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(target)) &#123;<br>        fs.<span class="hljs-title function_">mkdirSync</span>(target)<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(source)<br><br>    files.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> sourceFilePath = path.<span class="hljs-title function_">join</span>(source, file)<br>        <span class="hljs-keyword">const</span> targetFilePath = path.<span class="hljs-title function_">join</span>(target, file)<br><br>        <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">lstatSync</span>(sourceFilePath).<span class="hljs-title function_">isDirectory</span>()) &#123;<br>            <span class="hljs-title function_">copyFolderSync</span>(sourceFilePath, targetFilePath)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fs.<span class="hljs-title function_">copyFileSync</span>(sourceFilePath, targetFilePath)<br>        &#125;<br>    &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>preload是electron的预加载文件，例如IPC通信、vue与electron通信桥梁都可以在这里面定义，以下是electron官网的介绍</p><blockquote><p>什么是预加载脚本，并且学会如何使用预加载脚本来安全地将特权 API 暴露至渲染进程中。 不仅如此，你还会学到如何使用 Electron 的进程间通信 (IPC) 模组来让主进程与渲染进程间进行通信。</p><p>Electron 的主进程是一个拥有着完全操作系统访问权限的 Node.js 环境。 除了 <a href="https://www.electronjs.org/zh/docs/latest/api/app">Electron 模组</a> 之外，您也可以访问 <a href="https://nodejs.org/dist/latest/docs/api/">Node.js 内置模块</a> 和所有通过 npm 安装的包。 另一方面，出于安全原因，渲染进程默认跑在网页页面上，而并非 Node.js里。</p><p>为了将 Electron 的不同类型的进程桥接在一起，我们需要使用被称为 <strong>预加载</strong> 的特殊脚本。</p><p><a href="https://www.electronjs.org/zh/docs/latest/tutorial/tutorial-preload">  electron预加载文档  </a></p></blockquote><ul><li>preload&#x2F;index.ts</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/* eslint-disable eslint-comments/disable-enable-pair */</span><br><span class="hljs-comment">/* eslint-disable @typescript-eslint/no-var-requires */</span><br><br><span class="hljs-keyword">const</span> &#123; contextBridge, ipcRenderer &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>)<br><br>contextBridge.<span class="hljs-title function_">exposeInMainWorld</span>(<span class="hljs-string">&#x27;versions&#x27;</span>, &#123;<br>    <span class="hljs-attr">node</span>: <span class="hljs-function">() =&gt;</span> process.<span class="hljs-property">versions</span>.<span class="hljs-property">node</span>,<br>    <span class="hljs-attr">chrome</span>: <span class="hljs-function">() =&gt;</span> process.<span class="hljs-property">versions</span>.<span class="hljs-property">chrome</span>,<br>    <span class="hljs-attr">electron</span>: <span class="hljs-function">() =&gt;</span> process.<span class="hljs-property">versions</span>.<span class="hljs-property">electron</span><br>    <span class="hljs-comment">// 除函数之外，我们也可以暴露变量</span><br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ipcRenderer)<br><br></code></pre></td></tr></table></figure></li><li><p>plugins目录是vite-plugins，处理elctron开发环境与生产环境</p><ul><li>electron&#x2F;plugins&#x2F;vite-electron-build.ts</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs ts"># electron/plugins/vite-electron-build.<span class="hljs-property">ts</span><br><br><span class="hljs-comment">// 生产环境插件</span><br><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:fs&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:path&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123; <span class="hljs-title class_">Plugin</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> electronBuilder <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;electron-builder&#x27;</span><br><span class="hljs-keyword">import</span> &#123; buildBackground &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/build&#x27;</span><br><span class="hljs-keyword">import</span> &#123; emptyDirectorySync, copyFolderSync &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/handle-files&#x27;</span><br><br><span class="hljs-comment">// 源文件夹路径</span><br><span class="hljs-keyword">const</span> sourcePath = path.<span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">&#x27;dist&#x27;</span>)<br><br><span class="hljs-comment">// 目标文件夹路径</span><br><span class="hljs-keyword">const</span> targetPath = path.<span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">&#x27;./electron/dist&#x27;</span>)<br><br><span class="hljs-comment">// 导出 Vite 插件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ElectronBuildPlugin</span> = (): <span class="hljs-function"><span class="hljs-params">Plugin</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;electron-build&#x27;</span>,<br>        <span class="hljs-attr">closeBundle</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-comment">// 清空目标目录</span><br>            <span class="hljs-title function_">emptyDirectorySync</span>(targetPath)<br><br>            <span class="hljs-comment">// 执行复制操作</span><br>            <span class="hljs-title function_">copyFolderSync</span>(sourcePath, targetPath)<br><br>            <span class="hljs-comment">// 构建 Electron 后台脚本</span><br>            <span class="hljs-title function_">buildBackground</span>(<span class="hljs-string">&#x27;electron/background.ts&#x27;</span>, <span class="hljs-string">&#x27;electron/dist/background.js&#x27;</span>)<br>            <span class="hljs-comment">// 构建 preload预加载</span><br>            <span class="hljs-title function_">buildBackground</span>(<span class="hljs-string">&#x27;electron/preload/index.ts&#x27;</span>, <span class="hljs-string">&#x27;electron/dist/preload/index.js&#x27;</span>)<br><br>            <span class="hljs-comment">// 读取 package.json 文件并更新其中的 &quot;main&quot; 字段</span><br>            <span class="hljs-keyword">const</span> packageJson = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;package.json&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>            packageJson.<span class="hljs-property">main</span> = <span class="hljs-string">&#x27;./background.js&#x27;</span><br><br>            <span class="hljs-comment">// 写入更新后的 package.json 到目标文件夹</span><br>            fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;./electron/dist/package.json&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(packageJson, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>))<br><br>            <span class="hljs-comment">// 配置 Electron Builder 并执行构建</span><br>            <span class="hljs-keyword">const</span> outputDir = <span class="hljs-string">&#x27;./electron/dist/node_modules&#x27;</span><br><br>            <span class="hljs-comment">// 确保输出目录不存在时再创建</span><br>            <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(outputDir)) &#123;<br>                fs.<span class="hljs-title function_">mkdirSync</span>(outputDir)<br>            &#125;<br><br>            electronBuilder.<span class="hljs-title function_">build</span>(&#123;<br>                <span class="hljs-attr">config</span>: &#123;<br>                    <span class="hljs-attr">directories</span>: &#123;<br>                        <span class="hljs-attr">output</span>: path.<span class="hljs-title function_">resolve</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">&#x27;./electron/release&#x27;</span>),<br>                        <span class="hljs-attr">app</span>: targetPath<br>                    &#125;,<br>                    <span class="hljs-attr">asar</span>: <span class="hljs-literal">true</span>,<br>                    <span class="hljs-attr">appId</span>: <span class="hljs-string">&#x27;gzjstech.com&#x27;</span>,<br>                    <span class="hljs-attr">productName</span>: <span class="hljs-string">&#x27;vite-electron&#x27;</span>,<br>                    <span class="hljs-attr">nsis</span>: &#123;<br>                        <span class="hljs-attr">oneClick</span>: <span class="hljs-literal">false</span>,<br>                        <span class="hljs-attr">perMachine</span>: <span class="hljs-literal">false</span>,<br>                        <span class="hljs-attr">allowToChangeInstallationDirectory</span>: <span class="hljs-literal">true</span><br>                    &#125;<br>                &#125;<br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>vite-electron-dev.ts</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 开发环境插件</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123; <span class="hljs-title class_">AddressInfo</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;net&#x27;</span><br><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:fs&#x27;</span><br><span class="hljs-keyword">import</span> &#123; spawn, <span class="hljs-keyword">type</span> <span class="hljs-title class_">ChildProcessWithoutNullStreams</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;child_process&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123; <span class="hljs-title class_">Plugin</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> &#123; buildBackground &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/build&#x27;</span><br><br><span class="hljs-comment">// 定义 Electron 进程变量</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">ElectronProcess</span>: <span class="hljs-title class_">ChildProcessWithoutNullStreams</span><br><br><span class="hljs-comment">// 导出 Vite 插件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ElectronDevPlugin</span> = (): <span class="hljs-function"><span class="hljs-params">Plugin</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;electron-dev&#x27;</span>,<br>        <span class="hljs-attr">configureServer</span>: <span class="hljs-function">(<span class="hljs-params">server</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 构建 Electron 后台脚本</span><br>            <span class="hljs-title function_">buildBackground</span>(<span class="hljs-string">&#x27;electron/background.ts&#x27;</span>, <span class="hljs-string">&#x27;electron/dist/background.js&#x27;</span>)<br><br>            <span class="hljs-comment">// 在服务器监听事件时</span><br>            server.<span class="hljs-property">httpServer</span>?.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;listening&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-comment">// 获取服务器地址信息</span><br>                <span class="hljs-keyword">const</span> addressInfo = server.<span class="hljs-property">httpServer</span>?.<span class="hljs-title function_">address</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">AddressInfo</span><br>                <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IP</span> = <span class="hljs-string">`http://localhost:<span class="hljs-subst">$&#123;addressInfo.port&#125;</span>`</span><br><br>                <span class="hljs-comment">// 启动 Electron 进程</span><br>                <span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/no-var-requires</span><br>                <span class="hljs-title class_">ElectronProcess</span> = <span class="hljs-title function_">spawn</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>, [<br>                    <span class="hljs-string">&#x27;electron/dist/background.js&#x27;</span>,<br>                    <span class="hljs-variable constant_">IP</span><br>                ])<br><br>                <span class="hljs-comment">// 监听后台脚本文件的变化，重新启动 Electron 进程</span><br>                fs.<span class="hljs-title function_">watchFile</span>(<span class="hljs-string">&#x27;electron/background.ts&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-title class_">ElectronProcess</span>.<span class="hljs-title function_">kill</span>() <span class="hljs-comment">// 终止现有 Electron 进程</span><br>                    <span class="hljs-title function_">buildBackground</span>(<span class="hljs-string">&#x27;electron/background.ts&#x27;</span>, <span class="hljs-string">&#x27;electron/dist/background.js&#x27;</span>) <span class="hljs-comment">// 重新构建后台脚本</span><br>                    <span class="hljs-comment">// eslint-disable-next-line @typescript-eslint/no-var-requires</span><br>                    <span class="hljs-title class_">ElectronProcess</span> = <span class="hljs-title function_">spawn</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;electron&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>, [<br>                        <span class="hljs-string">&#x27;electron/dist/background.js&#x27;</span>,<br>                        <span class="hljs-variable constant_">IP</span><br>                    ]) <span class="hljs-comment">// 启动新的 Electron 进程</span><br>                &#125;)<br><br>                <span class="hljs-comment">// 监听 Electron 进程的错误输出</span><br>                <span class="hljs-title class_">ElectronProcess</span>.<span class="hljs-property">stderr</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`electron process: <span class="hljs-subst">$&#123;data.toString()&#125;</span>`</span>)<br>                &#125;)<br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="vite-config-ts"><a href="#vite-config-ts" class="headerlink" title="vite.config.ts"></a>vite.config.ts</h2></li></ul></li><li><p>引入我们编写的vite插件并注册</p></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; fileURLToPath, <span class="hljs-variable constant_">URL</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:url&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">UnoCSS</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unocss/vite&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElectronDevPlugin</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./electron/plugins/vite-electron-dev&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElectronBuildPlugin</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./electron/plugins/vite-electron-build&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>    <span class="hljs-attr">envPrefix</span>: <span class="hljs-string">&#x27;APPLET_&#x27;</span>,<br>    <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>(), <span class="hljs-title class_">UnoCSS</span>(), <span class="hljs-title class_">ElectronDevPlugin</span>(), <span class="hljs-title class_">ElectronBuildPlugin</span>()],<br>    <span class="hljs-attr">base</span>: <span class="hljs-string">&#x27;./&#x27;</span>,<br>    <span class="hljs-attr">resolve</span>: &#123;<br>        <span class="hljs-attr">alias</span>: &#123;<br>            <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./src&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>))<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">server</span>: &#123;<br>        <span class="hljs-attr">proxy</span>: &#123;<br>            <span class="hljs-comment">// 跨域代理</span><br>            <span class="hljs-string">&#x27;/apis&#x27;</span>: &#123;<br>                <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://&#x27;</span> + env.<span class="hljs-property">VUE_APP_BASE_API</span>,<br>                <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/apis/</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>            &#125;<br>            <span class="hljs-comment">// 代理 WebSocket 或 socket</span><br>            <span class="hljs-comment">// &#x27;/socket.io&#x27;: &#123;</span><br>            <span class="hljs-comment">//   target: &#x27;ws://localhost:3000&#x27;,</span><br>            <span class="hljs-comment">//   ws: true</span><br>            <span class="hljs-comment">//  &#125;</span><br>        &#125;<br>    &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><h2 id="preload注入后无法在web层获取相关变量"><a href="#preload注入后无法在web层获取相关变量" class="headerlink" title="preload注入后无法在web层获取相关变量"></a>preload注入后无法在web层获取相关变量</h2><ul><li><p>需要在scr下新建global.d.ts，并且在tsconfig.app.json里面引入</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> &#123; <span class="hljs-title class_">Method</span>, <span class="hljs-title class_">ResponseType</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">export</span> &#123;&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> &#123;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Window</span> &#123;<br>        <span class="hljs-comment">// 这里新增preload里面的注入变量，防止window.versions报错</span><br>        electronAPI?: <span class="hljs-built_in">any</span> <span class="hljs-comment">//全局变量名</span><br>        versions?: <span class="hljs-built_in">any</span> <span class="hljs-comment">//</span><br>    &#125;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AxiosConfig</span> &#123;<br>        params?: <span class="hljs-built_in">any</span><br>        data?: <span class="hljs-built_in">any</span><br>        url?: <span class="hljs-built_in">string</span><br>        method?: <span class="hljs-title class_">Method</span><br>        headersType?: <span class="hljs-built_in">string</span><br>        responseType?: <span class="hljs-title class_">ResponseType</span><br>    &#125;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IResponse</span>&lt;T = <span class="hljs-built_in">any</span>&gt; &#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span><br>        <span class="hljs-attr">data</span>: T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span> ? T : T &amp; <span class="hljs-built_in">any</span><br>    &#125;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosHeaders</span> =<br>        | <span class="hljs-string">&#x27;application/json&#x27;</span><br>        | <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>        | <span class="hljs-string">&#x27;multipart/form-data&#x27;</span><br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">window</span>: <span class="hljs-built_in">any</span><br><br></code></pre></td></tr></table></figure><ul><li><p>tsconfig.app.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;extends&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;@vue/tsconfig/tsconfig.dom.json&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">// &quot;include&quot;: [&quot;env.d.ts&quot;, &quot;src/**/*&quot;, &quot;src/**/*.vue&quot;],</span><br>  <span class="hljs-attr">&quot;include&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/**/*.ts&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;src/**/*.d.ts&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;src/**/*.tsx&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;src/**/*.vue&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;electron/**/*.ts&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;src/**/__tests__/*&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;composite&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;baseUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;@/*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;./src/*&quot;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;types&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;three&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="打包注意点"><a href="#打包注意点" class="headerlink" title="打包注意点"></a>打包注意点</h2><ul><li>需要在根目录新建 .npmrc文件把下面的三行复制进去，这样打包才不会报错</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">ELECTRON_MIRROR</span>=<span class="hljs-attr">https</span>:<span class="hljs-comment">//npmmirror.com/mirrors/electron/</span><br>registry=<span class="hljs-attr">https</span>:<span class="hljs-comment">//registry.npm.taobao.org/</span><br>electron_builder_binaries_mirror=<span class="hljs-attr">https</span>:<span class="hljs-comment">//npm.taobao.org/mirrors/electron-builder-binaries/</span><br></code></pre></td></tr></table></figure><blockquote><p>集成方案来自b站up主小满zs，与借鉴了electron-vite框架，在他们的基础上完善了这一版，通过vite生命周期实现打包完成vite后再打包electron，这样开发模式启动时就能带起electron</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用picgo配合easyImage搭建富文本粘贴自动上传</title>
    <link href="/2023/11/16/2023-11-16-%E4%BD%BF%E7%94%A8picgo%E9%85%8D%E5%90%88easyImage%E6%90%AD%E5%BB%BA%E5%AF%8C%E6%96%87%E6%9C%AC%E7%B2%98%E8%B4%B4%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0/"/>
    <url>/2023/11/16/2023-11-16-%E4%BD%BF%E7%94%A8picgo%E9%85%8D%E5%90%88easyImage%E6%90%AD%E5%BB%BA%E5%AF%8C%E6%96%87%E6%9C%AC%E7%B2%98%E8%B4%B4%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="使用picgo配合easyImage搭建富文本粘贴自动上传"><a href="#使用picgo配合easyImage搭建富文本粘贴自动上传" class="headerlink" title="使用picgo配合easyImage搭建富文本粘贴自动上传"></a>使用picgo配合easyImage搭建富文本粘贴自动上传</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">body</span>：&#123;<span class="hljs-string">&quot;token&quot;</span>:<span class="hljs-string">&quot;你的简单图床apitoken&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://tuchuang.junsen.online//i/2023/11/16/iw82mw-1.png" alt="image-20231116114250759"></p><p>然后去typora 设置图片上传配置选择picgoapp</p><p><img src="https://tuchuang.junsen.online//i/2023/11/16/j03nxl-1.png" alt="image-20231116114902405"></p>]]></content>
    
    
    <categories>
      
      <category>自动化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git配置</title>
    <link href="/2023/11/15/git%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/11/15/git%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="新环境配置git多配置"><a href="#新环境配置git多配置" class="headerlink" title="新环境配置git多配置"></a>新环境配置git多配置</h1><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-keygen -t rsa -C <span class="hljs-string">&#x27;xxx@qq.com&#x27;</span> -f ~<span class="hljs-regexp">/.ssh/gi</span>tee_id_rsa<br>ssh-keygen -t rsa -C <span class="hljs-string">&#x27;xxx@qq.com&#x27;</span> -f ~<span class="hljs-regexp">/.ssh/gi</span>thub_id_rsa<br>ssh-keygen -t rsa -C <span class="hljs-string">&#x27;xxx@qq.com&#x27;</span> -f ~<span class="hljs-regexp">/.ssh/gi</span>tlab_id_rsa<br></code></pre></td></tr></table></figure><h2 id="config配置"><a href="#config配置" class="headerlink" title="config配置"></a>config配置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># gitee</span><br>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>IdentityFile ~<span class="hljs-regexp">/.ssh/gi</span>tee_id_rsa<br><span class="hljs-comment"># github</span><br>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~<span class="hljs-regexp">/.ssh/gi</span>thub_id_rsa<br><span class="hljs-comment"># 璟胜gitlab</span><br>Host gitlab.xxx.com<br>HostName gitlab.xxx.com<br>PreferredAuthentications publickey<br>IdentityFile ~<span class="hljs-regexp">/.ssh/gi</span>thlab_id_rsa<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宝塔使用webhook同步github代码</title>
    <link href="/2023/11/14/%E5%AE%9D%E5%A1%94%E4%BD%BF%E7%94%A8webhook%E5%90%8C%E6%AD%A5github%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/11/14/%E5%AE%9D%E5%A1%94%E4%BD%BF%E7%94%A8webhook%E5%90%8C%E6%AD%A5github%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>宝塔使用webhook同步github代码</p><h2 id="github设置access-token"><a href="#github设置access-token" class="headerlink" title="github设置access_token"></a>github设置access_token</h2><p><img src="https://tuchuang.junsen.online/i/2024/04/18/12h3kqt-2.png" alt="image-20240418232642741"></p><p><img src="https://tuchuang.junsen.online/i/2024/04/18/12i78oa-2.png" alt="image-20240418232834618"></p><h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><p><img src="https://tuchuang.junsen.online/i/2024/04/18/12ibc5r-2.png" alt="image-20240418232853582"></p><h2 id="给git-action把绑定token"><a href="#给git-action把绑定token" class="headerlink" title="给git action把绑定token"></a>给git action把绑定token</h2><p><img src="https://tuchuang.junsen.online/i/2024/04/18/12hnsji-2.png" alt="image-20240418232743376"></p><h3 id="服务器设置git"><a href="#服务器设置git" class="headerlink" title="服务器设置git"></a>服务器设置git</h3><ul><li><p>先去 服务器上设置github用户名、邮箱、密码</p></li><li><p>然后获取rsa密钥用于代码拉取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;xxx&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;xxx@qq.com&quot;</span><br>git config --global user.password <span class="hljs-string">&quot;xxx&quot;</span><br><br><span class="hljs-comment">#生成公钥</span><br>ssh-keygen -t rsa<br><span class="hljs-comment">#获取公钥</span><br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></li></ul><h2 id="宝塔软件商店搜索-webhook"><a href="#宝塔软件商店搜索-webhook" class="headerlink" title="宝塔软件商店搜索 webhook"></a>宝塔软件商店搜索 webhook</h2><p><img src="https://tuchuang.junsen.online/i/2024/04/18/12iy9j2-2.png" alt="img"></p><ul><li>点击设置添加hook，名称随便填，脚本复制以下的改下仓库地址和部署目录</li><li><strong>注意点：</strong> 仓库的代码需要是编译后的代码。可以利用git action自动编译</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment">#输出当前时间</span><br><span class="hljs-built_in">date</span> --<span class="hljs-built_in">date</span>=<span class="hljs-string">&#x27;0 days ago&#x27;</span> <span class="hljs-string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start&quot;</span><br><span class="hljs-comment">#git项目路径</span><br>gitPath=<span class="hljs-string">&quot;/www/wwwroot/部署文件夹&quot;</span><br><span class="hljs-comment">#git 网址</span><br>gitHttp=<span class="hljs-string">&quot;仓库地址&quot;</span><br> <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Web站点路径：<span class="hljs-variable">$gitPath</span>&quot;</span><br> <br><span class="hljs-comment">#判断项目路径是否存在</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$gitPath</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">cd</span> <span class="hljs-variable">$gitPath</span><br>        <span class="hljs-comment">#判断是否存在git目录</span><br>        <span class="hljs-keyword">if</span> [ ! -d <span class="hljs-string">&quot;.git&quot;</span> ]; <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;在该目录下克隆 git&quot;</span><br>                <span class="hljs-built_in">cd</span> ..<br>                git <span class="hljs-built_in">clone</span> <span class="hljs-variable">$gitHttp</span> <br>                <span class="hljs-comment"># mv gittemp/.git .</span><br>                <span class="hljs-comment"># rm -rf gittemp </span><br>                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;End&quot;</span><br>        <span class="hljs-keyword">else</span>  <br>              <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;在该目录下拉取 git&quot;</span><br>              git pull 2&gt;&amp;1<br>              <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;End&quot;</span><br>        <span class="hljs-keyword">fi</span><br>        <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;该项目路径不存在&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;End&quot;</span><br>        <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><ul><li><p>获取添加后的 hook地址去github仓库里的设置点击webhook添加宝塔生成的hook地址，填完后点击add webhook即可，第一次需要点击下宝塔webhook的测试按钮</p><p><img src="https://tuchuang.junsen.online/i/2024/04/18/12jbm3x-2.png" alt="img"></p></li></ul><p><img src="https://tuchuang.junsen.online//i/2023/11/14/t0yp1j-1.png" alt="image-20231114175513385"></p><p><img src="https://tuchuang.junsen.online/i/2024/04/18/12iucss-2.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>自动化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自动化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>久违的博客记录</title>
    <link href="/2023/11/03/%E4%B9%85%E8%BF%9D%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/11/03/%E4%B9%85%E8%BF%9D%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>记录下：2023-11-03重新写博客</p><p><img src="https://tuchuang.junsen.online//i/2023/11/14/retmd0-1.jpg" alt="5848e4a37f5e4fb39f4c4384a9c27523"></p><p><img src="https://tuchuang.junsen.online//i/2023/11/14/sjxupp-1.jpg" alt="5c23d52f880511ebb6edd017c2d2eca2"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/03/hello-world/"/>
    <url>/2023/11/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
